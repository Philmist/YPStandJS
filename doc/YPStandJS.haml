-# vim: fileencoding=utf-8
!!! 5
%html
  %head
    %title YPを作って学ぶJavascript
    %meta{"http-equiv"=>"content-type", :content=>"text/html; charset=utf-8"}
    %meta{"http-equiv"=>"content-style-type", :content=>"text/css"}
    %link{:rel=>"stylesheet", :href=>"style.css", :type=>"text/css"}
  %body
    %section
      %h1 YPを作って学ぶJavascript
      %section
        %h2 前書き
        %section
          %h3 この文書について
          %p
            この文書はnode.jsを使ってJavascriptを勉強し始めたど素人が、
            YPを作ることによっていろいろ学習していく過程をまとめたものです。
          %p
            もしも、この文書が、何かのお役に立つなら幸いです。
        %section
          %h3 注意点
          %p
            この文書はあくまでも一人の主観と独学によって書かれています。
            したがって、Javascriptやnode.jsの一般的なセオリーから外れていることが多いかもしれません。
            もし、そのようなことがあったり、あるいは何らかの間違いがあったとしても、ご笑覧いただければと思います。
      %section
        %h2 node.jsで遊ぼう
        %p
          この章ではnode.jsの紹介と導入、そして簡単なJavascriptプログラムについて学習します。
        %section
          %h3 node.jsとは何か
          %p
            これからYPを作るにあたって、
            node.jsというソフトを使っていくわけですが、
            簡単にこのソフトを紹介したいと思います。
          %p
            node.jsはChromeのJavascriptエンジン(V8エンジンと呼ばれています)を使った、
            軽量でありかつ高速にネットワークアプリケーションを動かすためのプラットフォームです。
            その性能は
            %a{:href=>"http://nodejs.org/industry/"}多数の企業で使われている
            ことからも折り紙付きといえるでしょう。
          %p
            大きな特徴は、イベント駆動であり、ノンブロッキングでほぼすべての動作が実行されるということです。
            この特徴はプログラムを作る際に大きく関わってくるので、また後ほど説明します。
        %section
          %h3 node.jsのダウンロードとインストール
          %p WindowsでもMacでもインストールは簡単です。
          %p
            %a{:href=>"http://nodejs.org/download/"}公式のダウンロードページ
            にインストーラがあるのでそれをダウンロードして実行するだけです。
            もちろん、Windowsの場合には管理者権限など考慮することをお忘れなく。
          %p
            Linux用のバイナリも配布されていますが、
            ディストリビューションで用意されてるパッケージマネージャを使う方が無難でしょう。
        %section
          %h3 npmとは
          %p
            npmとはnode.js専用のパッケージマネージャです。
            Rubyに親しみがある人ならgem、
            Pythonに親しみがある人ならpipと言えばわかるでしょうか。
            これを使うことによって、簡単に依存関係を意識することなく、パッケージを導入することができます。
          %p
            なお、Windowsのインストーラを使った場合、npmを使う際には若干落とし穴があります。
            それは環境変数
            %code NODE_PATH
            を設定することです。
            具体的には
            %a{:href=>"http://sucrose.hatenablog.com/entry/20120315/p1"} このページあたり
            を参照するとよいでしょう。
        %section
          %h3 node.jsを動かしてみる
          %p
            インストールは出来ましたか？
            ではnode.jsを動かしてみましょう。
          %figure
            %img{:src=>'./img/nodejs_initial.jpg'}
            %figcaption
              node.js(node.exe)起動時の画面
          %p
            node.jsは何も指定せずに起動すると、
            このように単純な画面が表示されます。
            Pythonのそれ、もしくはRubyのirbと似たようなものだと思っていただけるといいです。
          %p
            では、最初のお約束、"Hello, World!"を表示させてみましょう。
          %figure
            %img{:src=>'./img/nodejs_console_hello.jpg'}
            %figcaption
              node.jsで"Hello, World!"
          %p
            簡単ですね？
            コンソールを終了させるには、(Windowsの場合)CTRL+Cを2回押してください。
          %figure
            %img{:src=>'./img/nodejs_console_quit.jpg'}
            %figcaption
              node.jsを終了させる
        %section
          %h3 Hello,World! プログラム
          %p
            この節ではHello, World!プログラムを書くことで、
            簡単にJavascriptを紹介していきます。
          %section
            %h4
              %abbr{:title=>'Mozilla Developer Network'}MDN
              のJavascriptガイドとリファレンス
            %p
              これからJavascriptの説明などをしていくわけですが、
              その前にいくつかリファレンスの紹介をしていきたいと思います。
            %p
              まずはJavascript自体のリファレンスですが、
              これはMDNの
              %a{:href=>'https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide'}ガイド
              と
              %a{:href=>'https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference'}リファレンス
              が非常によい資料になると思います。
              正確にはJavascriptというより、
              ECMAScriptの資料なのですが、
              ブラウザごとの対応状況も載ってたりするなど非常に詳しいものです。
          %section
            %h4
              node.jsのAPIリファレンス
            %p
              node.jsにもリファレンスは提供されています。
              %a{:href=>'http://nodejs.org/api/'}これがnode.jsのAPIリファレンス(英語)
              です。
              %a{:href=>'http://nodejs.jp/nodejs.org_ja/api/'}有志による日本語リファレンス
              も整備されています。
            %p
              node.jsのプログラムを読み進める時、書いていく時には
              これらの文書に頼ると非常にはかどることでしょう。
          %section
            %h4
              関数の書き方
            %section
              %h5 名前あり関数
              %p
                では実際に"Hello, World!"プログラムを書いてみましょう。
                今度のプログラムは以前とは少々違うものです。
                次のコードをあなたのお好みのテキストエディタで打ち込み、
                文字コードをUTF-8にして保存してください。
              %pre
                :preserve
                  function printHello() {
                    console.log("Hello, World!");
                    return;
                  }
                  printHello();
              %p
                私はこのプログラムをfunchello.jsという名前で保存しました。
                では、実際に実行してみましょう。
              %figure
                %img{:src=>'./img/funchello.jpg'}
                %figcaption
                  funchello.jsを実行した様子
              %p
                期待した通りの結果が出たと思います。
                Javascriptでは関数を
                %code function 名前(引数1, 引数2, ...) { 文; }
                という形で定義します。
            %section
              %h5 無名関数(あるいはすべてがオブジェクトということ)
              %p 今度は次のコードを実行してみてください。
              %pre
                :preserve
                  var hello = function(v) {
                    console.log(v);
                    return;
                  };
                  hello("Hello, World!");
              %figure
                %img{:src=>'./img/funchello2.jpg'}
                %figcaption
                  やっぱり同じ結果になる
              %p
                このように同じ結果になったと思います。
                Javascriptでは(宣言しなくても使えますが)、
                変数を
                %code var 変数名 = 変数の中身;
                というようにして宣言しますが、
                では変数helloに入れられているものは何でしょうか。
              %p
                それはもちろん関数です。
                Javascriptでは関数もオブジェクトであり、
                関数は名前を書かなくても宣言できるのです。
                オブジェクトを宣言するにはどうするのか、ということについては、
                ずっと後のほうで説明します。
            %section
              %h5 関数を返すということ
              %p
                ついてこれているでしょうか？
                今度はかなり変わった形で、やはり同じ結果を出力するプログラムを書きます。
              %pre
                :preserve
                  function print(v) {
                    return function() {
                      console.log(v);
                    };
                  }
                  var hello = print("Hello, World!");
                  hello();
              %p 実行してみましょう。
              %figure
                %img{:src=>'./img/funchello3.jpg'}
                %figcaption
                  関数をもらって実行する
              %p
                理解できたでしょうか？
                関数の中で、渡された引数を使う関数を返しています。
                こういうテクニックはちょくちょく使われることがあるので、
                覚えておくと若干幸せになれます。
                もっと詳しく知りたい方は
                %a{:href=>'https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Closures'}MDNガイドの「クロージャ」
                を見てみるとよいでしょう。
            %section
              %h5 モジュールをエクスポートする、そして使う
              %p
                では今度は次のコードをfunchello4.jsという名前で保存してください。
              %pre
                :preserve
                  function printHello() {
                    console.log("Hello, World!");
                  }
                  exports.printHello = printHello;
              %p
                これを直接実行しないでくださいね？
                これを保存したディレクトリに移動して、node.jsを起動してみて、
                次のように入力してみてください。
                先頭の
                %code &gt;
                はnode.jsのプロンプトです。
              %pre
                :preserve
                  > var funchello4 = require('./funchello4');
                  > funchello4.printHello();
              %figure
                %img{:src=>'./img/funchello4.jpg'}
                %figcaption
                  エクスポートして他のところで使う例
              %p
                この例でわかるように、
                %code exports.オブジェクト名 = 外に出したいオブジェクト;
                とすることで、他のファイルから関数などを使うことができます。
              %p
                逆に使いたいファイルからは、
                %code var 変数名 = require('使いたいモジュール');
                とすることで、以降、
                %code 変数名.エクスポートされたオブジェクト
                という形で使うことができます。
      %section
        %h2 YPStand(YP大地に立つ)について
        %p
          この章では、YPStand(YP大地に立つ)を解析することで、
          YP実装に必要なPCPプロトコルを解説します。
        %section
          %h3 そもそもYPStand(YP大地に立つ)とは何か
          %p
            YPStand(もしくはYP大地に立つ、以下YPStand)とは、あれくまさんが作った、
            Peercast本体を使わない、簡易YPサーバーです。
            Peercast本体を使わず、しかもRubyで書かれたソースが添付されているので、
            YPに必要なPCPプロトコルを簡単に解析することができます。
        %section
          %h3 YPStandソースのざっくりした解説
          %section
            %h4 ソースを読む、その前に
            %p
              YPStandはRubyで書かれています。
              ですから、読む側にはある程度Rubyの知識が必要です。
              お手元に
              %a{:href=>'http://docs.ruby-lang.org/ja/2.1.0/doc/index.html'}Rubyのリファレンス
              を用意してお読みください。
              Rubyがわからない場合は、後ろの方でPCPプロトコルについてまとめてありますので、
              そちらまで飛ばしてもかまいません。
          %section
            %h4 初めはエントリポイントから
            %p
              YPStandはypstand.rbがエントリポイント(プログラムの開始時点)になります。
              その中で重要なのは以下の行です。
            %pre
              :preserve
                $root = PCPRootServer.new(
                  Settings['BindAddress']    || '0.0.0.0',
                  Settings['PCPPort']        || 7144,
                  Settings['AgentName']      || 'YPStand',
                  Settings['MaxConnections'] || 64
                )
            %p
              これは
              %code $root
              というグローバル変数(Rubyでは$で始まる変数はグローバル変数です)に、
              PCPRootServerのインスタンスを作成して代入しています。
              %code ||
              は
              %code 1 || 2
              と書かれた場合、1が真ならば1、そうでないならば2という演算子です(この演算子はJavascriptでも使えます)。
            %p
              ではこのPCPRootServerはどこで定義されているのでしょうか。
              それは頭のrequireを見ていけばわかります。
            %pre
              :preserve
                require 'yaml'
                require 'webrick'
                require 'ypstand/yp'
                require 'ypstand/channelinfo'
                require 'ypstand/utils'
            %p
              結論から言うと、PCPRootServerは
              %code ypstand/yp.rb
              で定義されています。
              ではそのファイルを見ていきましょう。
          %section
            %h4 PCPRootServerでの処理の流れ
            %p
              PCPRootServerは標準添付ライブラリgserverを用いて実装されています。
              gserverの使い方は
              %a{:href=>'http://docs.ruby-lang.org/ja/2.1.0/library/gserver.html'}Rubyのgserverの項
              を見ればすぐにわかるかと思います。
              一番最初に見るべきは、関数serveです。
            %pre
              :preserve
                def serve(sock)
                  request = read_header(sock)
                  case request
                  when PCPRequest
                    process_client_pcp(request, sock)
                  when HTTPRequest
                    process_client_http(request, sock)
                  else
                    #Do nothing
                  end
                end
            %p
              PCPに関する流れだけ見ると、これは簡単で、
              <code>read_header</code>を呼び出して、
              もらったヘッダ部分を<code>process_client_pcp</code>に渡しています。
              最初に<code>read_header</code>を見ていきましょう。
            %pre
              :preserve
                def read_header(io)
                  header = io.read(4)
                  if header=="pcp\n" then
                    len = io.read(4).unpack('V')[0]
                    raise "Length Error" unless len==4
                    PCPRequest.new(io.read(4).unpack('V')[0])
                  else
                    until /\r\n\r\n$/=~header do
                      header &lt;&lt; io.read(1)
                    end
                    parse_http_header(header)
                  end
                end
            %p
              まず最初にソケット(ネットワーク)から4バイトだけ読み込みます。
              それが<code>pcp\n</code>(\nは改行文字)だったら、さらに4バイト読み込みます。
            %p
              <code>unpack</code>はRuby特有の機能かつ、PCPを見ていく上でも重要なので、
              %a{:href=>'http://docs.ruby-lang.org/ja/2.1.0/class/Array.html#I_PACK'}リファレンスのテンプレート文字列
              の項を見ながら説明していきます。
              <code>unpack</code>は(バイナリ)文字列を配列に変換するインスタンスメソッド(関数)です。
              この場合は<code>V</code>1文字なので、リトルエンディアンの符号なし32ビット整数を表しています。
              PCPで他によく使われるフォーマット文字列は他に<code>C*</code>(任意長の8ビット符号なし整数)、
              <code>Z4</code>(空きにnull文字(\0)を詰めた4文字の文字列)などがあります。
            %p
              つまり、ヘッダの部分をバイト列で表すとこうです。
            %pre
              :preserve
                PPPPLLLLVVVV
            %p
              Pの部分にはPCPプロトコルを表すヘッダ、<code>"pcp\n"</code>が入ります。
              その次のLの部分は、続くデータのバイト長をリトルエンディアン32ビット整数で表したものが入ります。
              なお、ヘッダの場合はここは常に4であることが想定されます。
              最後のVの部分、これはPCPのプロトコルバージョンを表しています。
              やはりこれもリトルエンディアン32ビット整数です。
              なお、後からわかりますが、現行のPeercastではこれも常に1です。
            %p
              では次に、<code>process_client_pcp</code>を見てみましょう。
            %pre
              :preserve
                def process_client_pcp(request, sock)
                  raise PCPError.new('Unknown PCP Version', PCP_ERROR_QUIT+PCP_ERROR_GENERAL) unless request.version==1
                  helo = PCPAtom.read(sock)
                  raise PCPError.new('Handshake failed', PCP_ERROR_QUIT+PCP_ERROR_GENERAL) unless helo.name==PCP_HELO
                  host = on_helo(sock, helo)
                  until @closed do
                    if IO.select([sock], [], [], 0.1) then
                      process_atom(sock, host, PCPAtom.read(sock))
                    end
                  end
                  PCPAtom.new(PCP_QUIT, nil, [PCP_ERROR_QUIT+PCP_ERROR_SHUTDOWN].pack('V')).write(sock)
                rescue PCPError => e
                  PCPAtom.new(PCP_QUIT, nil, [e.quit].pack('V')).write(sock)
                rescue PCPQuitError
                ensure
                end
            %p
              エラー処理の部分を除くと、そんなに難しいことはありません。
              ソケットからAtomを読み取って、HELOを処理して、あとは接続が切断されるまで延々とAtomを読み取って処理しているだけです。
              ってわかるわけないですよね？
            %p
              PCPAtomクラスのread関数を見てみましょう。
              これは<code>ypstand/peca.rb</code>で定義されています。
            %pre
              :preserve
                def self.read_blocking(stream, sz)
                  buf = stream.read(sz)
                  if buf then
                    while buf.bytesize&lt;sz do
                      res = stream.read(sz-buf.bytesize)
                      break unless res
                      buf &lt;&lt; res
                    end
                  end
                  buf
                end
                def self.read(stream)
                  buf = self.read_blocking(stream, 8)
                  if buf then
                    cmd, len = buf.unpack('Z4V')
                    if (len & 0x80000000)!=0 then
                      children = len & 0x7FFFFFFF
                      self.new(cmd, Array.new(children) { read(stream) }, nil)
                    else
                      self.new(cmd, nil, self.read_blocking(stream, len))
                    end
                  else
                    nil
                  end
                end
            %p
              <code>buf = self.read_blocking(stream, 8)</code>の部分から、
              PCPプロトコルのヘッダは常に8バイト区切りということがわかります。
              問題は<code>cmd, len = buf.unpack('Z4V')</code>の部分です(実は他にもread_blockingの部分には問題が隠されているのですがそれは後ほど)。
            %pre
              :preserve
                CCCCLLLL
            %p
              ここは最初の8バイトを先のように分割しています。
              <code>C</code>の部分はコマンド文字列(空きはnull文字で埋め)、
              <code>L</code>の部分はこの次に続く内容のバイト長を表しています。
              が、ちょっとここは特殊です。
              <code>L</code>の部分をビットで表してみると次のようになります。
            %pre
              :preserve
                ←上位                       下位→
                HLLLLLLL|LLLLLLLL|LLLLLLLL|LLLLLLLL
                |は8ビットごとの実際にはない区切り
            %p
              <code>H</code>のビットが重要です。
              このビットが立っていた場合、H以外のビットで、
              このAtomの次に子Atomがいくつ続くかを表しています。
              単位は個数です。次に出てくるヘッダでまた同じようなことを繰り返します。
            %p
              では、
              %code ypstand/yp.rb
              の<code>process_client_pcp</code>に戻って続きを見ていきましょう。
              次に出てくるのはこの行です。
            %pre
              :preserve
                host = on_helo(sock, helo)
            %p
              問題のon_helo関数を見てみましょう。
            %pre
              :preserve
                def on_helo(sock, atom)
                  host = Host.new
                  host.session_id   = atom[PCP_HELO_SESSIONID]
                  host.broadcast_id = atom[PCP_HELO_BCID]
                  host.agent        = atom[PCP_HELO_AGENT]
                  host.ip           = sock.peeraddr[3]
                  host.version      = atom[PCP_HELO_VERSION]
                  if atom[PCP_HELO_PING] then
                    host.port = pcp_ping(host.session_id, sock.peeraddr[3], atom[PCP_HELO_PING])
                  else
                    host.port = atom[PCP_HELO_PORT] || 0
                  end
                  oleh = PCPAtom.new(PCP_OLEH, [], nil)
                  oleh[PCP_HELO_AGENT]     = @agent_name
                  oleh[PCP_HELO_SESSIONID] = @session_id
                  oleh[PCP_HELO_VERSION]   = 1218
                  oleh[PCP_HELO_REMOTEIP]  = sock.peeraddr[3]
                  oleh[PCP_HELO_PORT]      = port
                  oleh.write(sock)
                  host
                end
            %p
              <code>pcp_ping</code>を除けば、やっていることはそこまで難しくありません。
              PCP_HELOというAtomの子Atomから必要な情報を保存し、
              PCP_OLEHというAtomを作って、クライアントに送信しているわけです。
              このHELOを受け取ったらOLEHを返すという流れは非常に重要です。
            %p
              <code>on_helo</code>の次は<code>process_atom</code>です。
              コードを以下に示します。
            %pre
              :preserve
                def process_atom(sock, host, atom)
                  return unless atom
                  case atom.name
                  when PCP_BCST; on_bcst(sock, host, atom)
                  when PCP_HOST; on_host(sock, host, atom)
                  when PCP_CHAN; on_chan(sock, host, atom)
                  when PCP_QUIT; on_quit(sock, host, atom)
                  end
                end
            %p
              ソースを見てもらうとわかりますが、
              PCP_HOSTとPCP_CHANというAtomにはチャンネルの情報が含まれています。
              そして、予想されるとは思いますが、配信が終了すると、PCP_QUITというAtomが送信されてきます。
            %p
              これで、おおよそ、YPStandの解説は終わりです。
              ではPCPの仕様をまとめてみましょう。
        %section
          %h3 YPStandからわかるPCPプロトコル仕様
          %p
            この節では、YPに必要なだけのPCPプロトコル仕様を解説します。
          %section
            %h4 PCPパケットの構造
            %p
              PCPパケットはヘッダとコンテンツの2つの部分に分かれており、
              ヘッダは次のような構造をしています(1文字=1バイト/オクテット)。
            %pre
              :preserve
                CCCC1234
            %p
              <code>C</code>の部分はnull文字(\0)で空きが埋められたコマンド文字列です。
              たとえばPCP_HELOというAtomの場合、ここには<code>helo</code>という文字列が、
              PCP_QUITの場合、<code>quit</code>という文字列が入ります。
            %p
              <code>1234</code>の部分はリトルエンディアン32ビット符号なし整数で表現された、
              コンテンツの長さ(バイト単位)、あるいは子Atomの個数を表します。
              リトルエンディアンなので、十進数の<code>1</code>を表すと、
              <code>0x1,0x0,0x0,0x0</code>のような並び順になります。
              重要なのは(順番を元通りにした後の)最上位ビットの扱いで、
              最上位ビットが1の場合、残りのビットで子Atomの個数を表すということです。
              この場合、このヘッダの直後に子Atomのヘッダ(とその中身)が入れ子のように表れます。
          %section
            %h4 YPとやりとりされるデータの流れ
            %p
              では実際にYPとデータをやりとりする流れを見てみましょう。
            %ol
              %li
                %dl
                  %dt (クライアント)PCPプロトコルヘッダとバージョンをYPに送出する
                  %dd
                    まず、クライアントはYP側(サーバー)にPCPバージョンを含んだヘッダを送出します。
                    これによってサーバーはPCPプロトコルであることを認識します。
                  %dd
                    %pre
                      :preserve
                        参考:
                        |p|c|p|\n|0x4|0x0|0x0|0x0|0x1|0x0|0x0|0x0|
                        |command |内容長         |バージョン     |
              %li
                %dl
                  %dt (クライアント)PCP_HELOをサーバーに送出する
                  %dd
                    クライアントはPCP_HELO('helo')コマンドと必要な情報をサーバーに送出します。
                    この情報にはブロードキャストID、
                    セッションID、使っているクライアント名などが含まれます。
              %li
                %dl
                  %dt (サーバー)PCP_OLEHをクライアントに送出する
                  %dd
                    サーバーはクライアントの(サーバー側から見たときの)IPアドレス、
                    (クライアントの配信用)ポート、
                    そして自身のクライアント名などを含んだ情報を含む
                    PCP_OLEH('oleh')コマンドをクライアントに送出します。
                    なお、この際にポートが0であった場合、
                    それはクライアントの配信用ポート(例:7144)が開いていないことを意味します。
                  %dd
                    PCP_HELOとPCP_OLEHを送り合うこのやり方をPCPハンドシェイクと呼称することがあります。
                    これはサーバー側からクライアントのポートの開放確認の際にも行われます。
                    ちなみにこれから作るYPではこの解放確認処理は省略します。
              %li
                %dl
                  %dt (クライアント)定期的にもしくは情報変更時にPCP_BCSTを送信する
                  %dd
                    クライアントは定期的に、あるいは自身の配信情報などが変更された際に、
                    PCP_BCST('bcst')コマンドをサーバーに送出します。
                    これはいわゆるKeep-Aliveの役目も果たします。
                    PCP_BCSTの中に含まれるAtomの中で重要なものは以下の2つです。
                  %dd
                    %dl
                      %dt PCP_CHAN('chan')
                      %dd
                        このAtomの中には自身のチャンネルID、
                        流している配信のビットレート、ジャンル、タイプなどが含まれます。
                      %dd
                        PCP_CHANで流れる情報の中で最も重要なのは「チャンネルID」です。
                        PeercastクライアントはこのチャンネルIDと配信者IPアドレスによって、
                        Peercastのリレーを確立します。
                      %dt PCP_HOST('host')
                      %dd
                        このAtomの中にも自身のチャンネルIDが含まれ、
                        他にブロードキャストID、自身のリレー数とリスナー数などが含まれます。
                      %dd
                        こちらはいわゆる自身の「枝」の情報が含まれています。
                        説明を見ればわかるとおり、「リスナー数は自己申告」です。
              %li
                %dl
                  %dt (クライアント/サーバー)配信/YPを終了する際にPCP_QUITを送信する
                  %dd
                    最終的に配信/YPを終了する際には、PCP_QUIT('quit')を相手側に送信します。
                    このAtomにはどのような理由で接続を終了するかのフラグが含まれます。
                  %dd
                    このAtomを送出せずに落ちた場合、相手側にゴミが残る場合があります。
                    なるべくなら送出してから接続を切断しましょう。
      %section
        %h2 YPStandJSを作る
        %p この章では、実際にnode.jsとJavascriptを使って、YPStandのJavascript移植版、YPStandJSを作ります。
        %section
          %h3 パケットを読むだけのサーバーを作る
          %p この節では、実際にYPStandJSを作る前段階として、パケットを読み取るだけのサーバーを作ります。
          %section
            %h4 ソースコード紹介
            %p
              では実際に動くソースコードを見てみましょう。
            %pre
              :preserve
                var net = require("net");
                var util = require("util");
                var sv = net.createServer(
                  function(s) {
                    s.on("readable",
                      function() {
                        var d = s.read();
                        if (d != null) {
                          console.log(util.inspect(d));
                        }
                      }
                    );
                  }
                );
                sv.listen(7146,
                  function() {
                    console.log("Sever listen on port 7146.");
                  }
                );
            %p
              短いコードですが、このコードにはnode.jsを理解するための基本が詰まっています。
          %section
            %h4 node.jsのイベントシステム
            %p
              node.jsはイベント駆動/ノンブロッキング入出力が特徴、と以前解説しました。
              ここではその詳細について解説します。
            %section
              %h5 イベント駆動の考え方
              %p
                node.jsではイベント駆動という考え方を採用しています。
                これは、node.jsがシングルスレッドで動いていることが大きいと理解しています。
              %p
                たとえば、ファイルの読み込みを考えてみましょう。
                ファイルの読み込みは時間のかかる処理です。
                node.jsはシングルスレッドで動いているために、
                ファイルの読み込みが完了するまで待つと他の処理まで止まってしまいます。
                ですから、その代わりにこうします。
                「ねぇ、ファイルの読み込みが終わったら、この関数を呼んでよ」、と。
                つまり、「ファイルの読み込みが終わった」というイベントに対して、「関数を呼ぶ」。
                これがイベント駆動です。
            %section
              %h5 ブロッキングとノンブロッキング
              %p
                ではブロッキングとノンブロッキングについて説明します。
              %p
                まず初めにブロッキングという概念を説明しましょう。
                これは「ある処理が終わるまで他の処理をしないで待つ」ということです。
                当然これでは、(マルチスレッドで処理をしない限り)他の処理を並行して行うことができません。
                たとえば、Webサーバーだったとしたら、複数ユーザーのリクエストを並行して受け付けることができないわけです。
              %p
                ではそれに対してノンブロッキングとは何かということを説明します。
                ノンブロッキングとは(イベント駆動の説明とかぶる部分もありますが)、
                「ある処理を受け付けたら、結果は後で返す」ということです。
                この「結果は後で返す」間に他の処理を挟むことが出来ます。
                つまり、Webサーバーの例ならば、他のユーザーからのリクエストも並行して受け付けられるわけです。
          %section
            %h4 ソースコードの分解/解説
            %p では先のソースコードをもっとわかりやすい形に分解してみましょう。
            %p
              無名関数は有名関数に置き換えることができます。たとえばこのような形に。
              ですが、すべての無名関数をこのように書き換えることができるわけではありません。
            %pre
              :preserve
                var f = function() {
                  console.log('Hello!');
                }
            %pre
              :preserve
                function hello() {
                  console.log('hello!');
                }
                var f = hello;
            %p
              つまり、先のソースコードはこのような形でも書けます。
            %pre
              :preserve
                var net = require("net");
                var util = require("util");
                function onConnection(socket) {
                  socket.on("readable",
                    function() {
                      data = socket.read();
                      if (data != null) {
                        console.log(util.inspect(data));
                      }
                    }
                  );
                }
                function onListening() {
                  console.log("Server listening.");
                }
                var server = net.createServer(onConnection);
                server.listen(7146, onListening);
            %p
              若干わかりやすくなったでしょうか？では解説していきましょう。
            %p
              1行目と2行目は必要なモジュールをrequireしています。
              <code>net</code>はネット関連のライブラリ、具体的にはサーバーとソケットを扱うライブラリが集まっています。
              <code>util</code>はnode.jsをデバッグしたりするときに便利なライブラリが集まっています。
            %p
              関数onConnectionとonListeningを飛ばして、
              先の方を見てみましょう。<code>net.createServer(onConnection)</code>とあります。
              <code>net.createServer</code>はTCPでの接続を受け入れるサーバーインスタンスを作成します。
              ではこれに渡されている関数onConnectionは何でしょうか。
              これは
              %a{:href=>"http://nodejs.org/api/net.html#net_event_connection"}"connection"イベント
              が起こった時に呼ばれる関数です。"connection"イベントが起こると、
              "Socket"オブジェクトを引数として関数が呼ばれます。
            %p
              そして、<code>server.listen(7146, onListening)</code>です。
              これは7146番ポートでサーバーの待ち受けを開始させます。
              onListening関数は"listening"イベント、つまり、待ち受けの準備が整った時に送出されるイベントです。
              node.jsはほぼすべてがノンブロッキングで実行されるので、
              <code>server.listen</code>が実行されても、すぐには待ち受けが開始されないのです。
            %p
              onConnection関数の中身を見ていきましょう。
          %section
            %h4 on(とonce)でイベントにつながる
            %p
              onConnection関数だけをもう一度抜粋します。
            %pre
              :preserve
                function onConnection(socket) {
                  socket.on("readable",
                    function() {
                      data = socket.read();
                      if (data != null) {
                        console.log(util.inspect(data));
                      }
                    }
                  );
                }
            %p
              2行目で<code>socket.on("readable", 関数)</code>ということをしています。
              これは何でしょうか。
            %p
              node.jsでは多くのオブジェクトがイベントを送出する"EventEmitter"です。
              EventEmitterには<code>オブジェクト.on("イベント名", 関数)</code>という形で
              イベントに連動して呼び出される関数を指定することができます。
              onにはもう一つ派生があってonceというのがあります。
              <code>オブジェクト.once("イベント名", 関数)</code>という形になります。
              こちらはイベントが発生したら「1回だけ」関数が呼び出されます。
              名前通りですね。
          %section
            %h4 バイナリを扱うBuffer型
            %p
              こんどは無名関数のところだけを抜粋します。
            %pre
              :preserve
                function() {
                  data = socket.read();
                  if (data != null) {
                    console.log(util.inspect(data));
                  }
                }
            %p
              socketはconnectionイベントで渡されるソケットオブジェクトです。
              そして、インスタンスメソッドのreadは任意の長さのデータを読み出す関数です。
              ここでは長さが指定されていないので、読み込めるだけすべてのデータを読み出しています。
              なお、読み出せないときには、この関数はnullを返します。
              長さが指定されているときにその長さが読み込めないときもnullを返します。
            %p
              では実際にデータを受け取って見ましょう。
              データを流してもらう相手はPeercastStationを使います。
            %p
              まずは次のような形で新規YPを追加してください。
            %figure
              %img{:src=>'./img/pecast_addyp.jpg'}
              %figcaption
                PeercastStationに新規YPを追加する
            %p
              そして次に、先ほどのプログラムをnode.jsで動かします。
            %figure
              %img{:src=>'./img/packetcapture_initial.jpg'}
              %figcaption
                パケットキャプチャを動かす
            %p
              最後に、node.jsで待ち受けしているポート(YP)に対して、配信を開始します。
              配信ソースは用意しなくてもかまいません。
            %figure
              %img{:src=>'./img/pecast_broadcast.jpg'}
              %figcaption
                配信設定の一例
            %figure
              %img{:src=>'./img/packetcapture_broadcast.jpg'}
              %figcaption
                配信をしてみた際のnode.jsの画面
            %p
              終わる時はnode.jsの画面でCTRL+C、そして、PeercastStation側で通常通り配信を終了させてください。
            %p
              では、このnode.js側の結果について解説していきます。
              <code>util.inspect(オブジェクト)</code>はオブジェクトを見やすい形式の文字列に変換する関数です。
              これは非常に便利なのでよく使います。
              ですが、整形された結果の<code>&lt;Buffer なんちゃらかんちゃら&gt;</code>とはなんでしょうか。
            %p
              これはnode.js特有の
              %a{:href=>'http://nodejs.org/api/buffer.html'}Buffer型
              と呼ばれるものです。
              Javascriptは文字列処理に関しては非常に優秀ですが、
              バイナリデータの処理に関しては貧弱です。
              それを補うためにBuffer型が作られているのです。
            %p
              Buffer型は基本的にバイト単位でデータを扱います。
              性質は配列によく似ており、<code>[]</code>を使うことや、
              <code>buf.length</code>で長さを参照することもできます。
              一番の特徴は、ネットワークなどでデータを扱うために、多数の関数が用意されていることです。
              従って、生のデータを扱う必要のあるYPStandJSでは、Buffer型を非常に多く用いることになります。
        %section
          %h3 peca.rbの定数と構造体を移植する
          %p
            この節ではYPStandでも最も重要な部分、ypstand/peca.rbのうち、
            定数と構造体を移植します。
          %section
            %h4 定数一覧を移植する
            %p
              Javascriptには定数というものは、(いまのところ)ありません。
              ですから、変数を使うわけですが、Rubyのまま移植しようとすると痛い目をみます。
            %pre
              :preserve
                # ypstand/peca.rbから
                PCP_HELO           = "helo"
                PCP_HELO_AGENT     = "agnt"
                (以下省略)
            %p
              これを素直にJavascriptで書くとこうなります。
            %pre
              :preserve
                var PCP_HELO = "helo";
                var PCP_HELO_AGENT = "agnt";
            %p
              なぜこれがまずいのでしょうか。
              それは別ファイルへエクスポートする時のことを考えるとわかります。
              変数ひとつひとつに対して、<code>exports.PCP_HELO = PCP_HELO;</code>と書かなければならなくなるのです。
              それはあまりにも非効率的です。
            %p
              では何を使うべきか。
              Rubyなどの他言語にある「連想配列」(あるキーに対して値があるようなもの)があればいいのですが、
              Javascriptにはそれそのものはありません。ですが、似たようなものはあります。
              それがオブジェクトです。
            %p
              Javascriptのオブジェクトとは何でしょうか。実は非常に単純な代物です。
              「文字列をキーとした連想配列」。それがオブジェクトです。
              つまり、ある文字列に対して、別の何かが結びつけられるのです。
            %p
              理屈はいいので実際にどうするのかを見てみましょう。
            %pre
              :preserve
                var PCP_CONST = {
                  PCP_HELO           :"helo",
                  PCP_HELO_AGENT     :"agnt",
                  PCP_HELO_OSTYPE    :"ostp",
                  PCP_HELO_SESSIONID :"sid",
                  PCP_HELO_PORT      :"port",
                  (中略)
                  PCP_ERROR_SHUTDOWN         :9,
                  PCP_ERROR_NOROOT           :10,
                  PCP_ERROR_BANNED           :11,
                };
                exports.PCP_CONST = PCP_CONST;
            %p
              Javascriptのオブジェクトは、<code>{ キー文字列 : 値, キー文字列 : 値, ... }</code>という形で作ることが出来ます。
              そして参照、もしくは代入する場合ですが、2つのやり方があります。
            %pre
              :preserve
                var obj["文字列"] = 値;
                var obj.文字列 = 値;
            %p
              この2つはどちらも同じ動作をしますが、前者は変数をキー文字列にしたいときに役に立ちます(後者ではそういう使い方ができません)。
              この文字列の部分を「プロパティ名」と呼び、値のことを「プロパティ」と呼びます。
          %section
            %h4 structを移植する
            %p
              Rubyのstructは構造体とも呼ばれ、
              名前があるメンバ変数を持つクラスです。
              たとえば次のように定義されます。
            %pre
              :preserve
                Meow = Struct.new(:count) do
                  def nya
                  end
                end
            %p
              この節ではstructが使われている重要な構造体、PCPAtomをどうやって移植するのかを考えながら、
              Javascriptでのオブジェクトについて理解していこうと思います。
            %section
              %h5 みんなみんなオブジェクト
              %p
                Javascriptでは(nullとすぐ後に説明するundefinedを除いた)すべてがオブジェクトです。
                そして標準ではstructに類するオブジェクトのコンストラクタは
                %a{:href=>"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects?redirectlocale=ja&redirectslug=JavaScript%2FReference%2FGlobal_Objects"}存在しません
                。
                ですから、必然的に、構造体はオブジェクトで代用することになります。
              %p
                まず、Rubyでの簡単な構造体を見てみましょう。
              %pre
                :preserve
                  Meow = Struct.new(:name)
              %p
                これがRubyでの簡単な構造体の定義の仕方です。
                では、これをJavascriptのオブジェクトを使って書いてみるとどうなるか。
                こうなります。
              %pre
                :preserve
                  function Meow(name) {
                    this.name = name;
                  }
              %p
                結局のところ、一般的なクラスのコンストラクタとして書いているわけです。
                実際に使うときはたとえばこうします。
              %pre
                :preserve
                  var cat = new Meow("chappy");
              %p
                ここで初めてnew演算子が出てきました。これはコンストラクタ関数から新しいオブジェクトを作るための演算子です。
                このようにしてJavascriptでは別の関数からオブジェクトを作成します。
            %section
              %h5 クラス関数を作る
              %p
                Rubyや他の言語ではクラス関数というものを持つことができます。
                つまり、コンストラクタから作られたインスタンスに属さず、
                クラス(Javascriptではコンストラクタ関数)に属する関数です。
                屁理屈はどうでもいいので実際に例を示します。
              %pre
                :preserve
                  function Cat() {
                  }
                  Cat.cry = function() {
                    console.log("Meow.");
                  }
                  Cat.cry();
              %p
                これだけです。
                Javascriptでは関数も例によってオブジェクトなので、
                それに新しくプロパティを作って関数を結びつけてやればいいのです。
            %section
              %h5 thisってなあに？
              %p
                ところで構造体の移植をする際に、
                thisという演算子(そう、thisは演算子です)が出てきました。
                この演算子は何でしょうか。
              %p
                これは一言で言うと、「現在実行されている部分(コンテキスト)のオブジェクトを参照する演算子」です。
                たとえば、これが関数内であれば関数を指しますし、
                グローバルな部分で実行されているのなら、グローバルなオブジェクトを参照します。
              %p
                実際のところ、私がどうこう言うより、
                %a{:href=>"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/this?redirectlocale=ja&redirectslug=JavaScript%2FReference%2FOperators%2Fthis"}Mozillaのガイド
                を見ていただけるとわかりやすいかと思います。ひどい話ですが。
            %section
              %h5 オブジェクトに属する関数(インスタンス関数)を作る、もしくはprototypeの説明
              %p
                今度は、インスタンス関数から作られた、オブジェクトに属する関数、
                つまり他の言語で言うところのインスタンス関数を作ってみましょう。
              %pre
                :preserve
                  function Cat() {
                  }
                  Cat.prototype.cry = function() {
                    console.log("Meow.");
                  }
              %p
                これでOKですが、ここに突如prototypeプロパティというものが出てきました(演算子ではありません)。
                これはいったい何なのでしょうか。
              %p
                Javascriptでは、オブジェクトが作成されると、prototypeに定義されているプロパティを使って、初期プロパティを生成します。
                これを利用して、他の言語にある継承を実装することができます。たとえばMDNにあるこの例のように。
              %pre
                :preserve
                  function Employee() {
                    this.name = "";
                    this.dept = "general";
                  }
                  function Manager() {
                    this.reports = [];
                  }
                  Manager.prototype = new Employee();
              %p
                これによって、他の言語で言う、EmployeeクラスからManagerクラスへの継承を実現することができます。
                実際に継承する代わりに、prototypeを代入することによって、初期プロパティを作るのです。
                これが、Javascriptがプロトタイプベースとも言われる由来です。
        %section
          %h3 Atomを読み込んでみる
          %p この節では、YPとPeercast間の通信単位になるAtomを実際に読み込んでみます。
          %section
            %h4 (失敗する)素直なAtomの読み込み方
            %p
              では、今までのことを踏まえて、素直にAtomを読み込んでみましょう。
              <code>ypstand/peca.rb</code>では次のように読み込み部分が書かれていました。
            %pre
              :preserve
                def self.read_blocking(stream, sz)
                  buf = stream.read(sz)
                  if buf then
                    while buf.bytesize&lt;sz do
                      res = stream.read(sz-buf.bytesize)
                      break unless res
                      buf &lt;&lt; res
                    end
                  end
                  buf
                end
                def self.read(stream)
                  buf = self.read_blocking(stream, 8)
                  if buf then
                    cmd, len = buf.unpack('Z4V')
                    if (len &amp; 0x80000000)!=0 then
                      children = len &amp; 0x7FFFFFFF
                      self.new(cmd, Array.new(children) { read(stream) }, nil)
                    else
                      self.new(cmd, nil, self.read_blocking(stream, len))
                    end
                  else
                    nil
                  end
                end
            %p
              これら2つの関数がAtom構造体の中に、クラス関数として入っていた(Rubyではself.functionでクラス関数を定義できます)わけです。
              read_blockingを考慮せずに、素直にself.read関数を移植してみましょう。
              こうなります。
            %pre
              :preserve
                function PCPAtom(name, children, content) {
                  this.name = name ? name : "";
                  this.children = children ? children : [];
                  this.content = content ? content : new Buffer(0);
                }
                PCPAtom.read(stream) {
                  var buf = stream.read(8);
                  var cmdstr = buf.toString('utf8', 0, 4);
                  var cmdlen = buf.readUInt32LE(4);
                  if ((cmdlen &amp; 0x80000000) != 0) {
                    var children = cmdlen &amp; 0x7FFFFFFF;
                    var childatom = [];
                    for (var i = 0; i &lt; children; i++) {
                      var tmpatom = PCPAtom.read(stream);
                      childatom.push(tmpatom);
                    }
                    return new PCPAtom(cmdstr, children, null);
                  } else {
                    return new PCPAtom(cmdstr, null, stream.read(cmdlen));
                  }
                }
            %p
              おおよそ、このような構成になるでしょう。
              非常にシンプルです。
              ですがこれでは一部の状況において正常なAtomが読み込まれません。
              それはなぜでしょうか。
          %section
            %h4 なぜAtomが読み込めないのか
            %p
              なぜAtomが読み込まれない状況が起きるのでしょうか。
              それは簡単です。
              stream.read関数(これはstream.Readableクラスのインスタンス関数です)は指定した長さが読み込めない時に「nullを返す」からです。
              ですから、先のRubyのコードではread_blockingという関数を実装して、指定した長さが必ず読み込まれるようにしています。
              では、node.jsでもこうすればよいのでしょうか？
            %p
              結論から言うとそれでは駄目なのです。
              なぜならば、node.jsはシングルスレッドで動作しているために、
              ある動作の間待ってしまうと、他の動作、たとえば他クライアントからのYPへの登録がその間できなくなってしまうのです。
              それはあまりよろしくありません。
              なお、Rubyではなぜ問題無いのかというと、クライアントの接続ごとに別スレッドを使っているからです。
            %p
              どのようにすればこの「ブロッキング」状態を解消して、「ノンブロッキング」な動作にできるのでしょうか。
              そのために私は少々複雑なロジックを導入しました。
          %section
            %h4 ステート(状態)という考え方
            %p
              要するに、nullを返されても、何処まで読み込んだのか、という状態を保持できればいいわけです。
              これをオブジェクトの中に「ステート(状態)」という形で保持します。
              次にデータが来たときは、ステートとすでに読み込んだデータを見て、Atomを構成していくのです。
            %p
              では実際にどのようなコードなのか見てみましょう。
            %pre
              :preserve
                PCPAtom.PCPAtomReader = function(stream) {
                  this.state = "INITIAL";
                  this.stream = stream;
                  this.atom = {};
                }
                PCPAtom.PCPAtomReader.prototype.read = function() {
                  while (true) {
                    switch (this.state) {
                      case "":
                      case "INITIAL":
                        var buf = this.stream.read(8);
                        if (!(buf)) {  // Can't read from stream
                          return null;
                        } else {
                          var cmdstr = buf.toString('utf8',0,4);  // cmd must be 4 or less letters
                          cmdlen = buf.readUInt32LE(4);
                          if ((cmdlen & 0x80000000) != 0) {  // cmd has children
                            this.atom.childlength = cmdlen & 0x7fffffff;
                            this.state = "WAITCHILD";
                            this.atom.command = cmdstr;
                            this.atom.childreader = new PCPAtom.PCPAtomReader(this.stream);
                            this.atom.children = [];
                            continue;
                          } else {
                            this.state = "WAITCONTENTS";
                            this.atom.command = cmdstr;
                            this.atom.length = cmdlen;
                            continue;
                          }
                        }
                        break;
                      case "WAITCONTENTS":
                        var buf = this.stream.read(this.atom.length);
                        if (!(buf)) {
                          return null;
                        } else {
                          var res = new PCPAtom(this.atom.command, null, buf);
                          this.state = "INITIAL";
                          this.atom = {};
                          return res;
                        }
                        break;
                      case "WAITCHILD":
                        var child = this.atom.childreader.read();
                        if (!(child)) {
                          return null;
                        } else {
                          this.atom.children.push(child);
                          this.atom.childlength = this.atom.childlength - 1;
                          if (this.atom.childlength > 0) {
                            continue;
                          } else {
                            var res = new PCPAtom(this.atom.command, this.atom.children, null);
                            this.state = "INITIAL";
                            this.atom = {};
                            return res;
                          }
                        }
                        break;
                    }
                  }
                }
            %p
              長いコードになってしまいましたが、解説していきます。
            %p
              まず最初に"INITIAL"ステートから開始します。
              このステートではコマンドと内容の長さを読み取ります。
              もしもコマンドが子を持つようであれば、子の数とコマンドをいったん保存し、
              読み取りクラスを新たに作って、"WAITCHILD"ステートに移行します。
              子を持たないようであれば、コマンドと内容の長さを保存して、"WAITCONTENTS"ステートに移行します。
            %p
              "WAITCONTENTS"ステートではただ単に、ひたすら指定された内容長のデータが来るまで待ちます。
              内容が来ればAtomを生成して返します。
            %p
              "WAITCHILD"ステートでは作った読み取りクラスを使って子を読み取り、
              一つずつ子を追加していきます。
              読み取り終わったらそのAtomを返します。
            %p
              重要なのはすべてのステートにおいて、
              必要なデータが読み取れなかった時はいったんnullを返すということです。
              このことによって、動作をブロックすることなく、呼び出し元に処理を返すことができるわけです。
        %section
          %h3 PCPハンドシェイクをする
          %p
            この節では、PCPプロトコルの基礎となる、PCPハンドシェイクを実際に行います。
          %section
            %h4 PCPハンドシェイクの流れ(復習)
            %p
              まず、PCPハンドシェイクとはどんなものかを簡単に復習します。
            %ol
              %li
                クライアントがYPにPCPのバージョンを含んだヘッダを送る
              %li
                クライアントがYPにブロードキャストID、セッションIDなどを含んだPCP_HELO Atomを送信する
              %li
                YPはクライアントに自身のクライアント名、セッションID、クライアントをYPから見たときの配信ポートとアドレスを含むPCP_OLEH Atomを送信する
            %p
              この手順を踏むと、あとはPCP_QUIT Atomがどちらかから送信されるまで、クライアントはYPに配信情報を送ることができます。
              具体的にはPCP_BCST Atomの子Atom、PCP_HOST Atom、PCP_CHAN Atomで配信情報を送ることになります。
          %section
            %h4 Atomを送信できる形に整形する
            %p
              Atomには様々な種類があります。
              どのAtomがどの種類になるのかはypstand/peca.rbでPacketTypeとして定義されています。
            %pre
              :preserve
                PacketType = {
                  PCP_HELO               => :parent,
                  PCP_OLEH               => :parent,
                  PCP_CHAN               => :parent,
                  PCP_CHAN_PKT           => :parent,
                  PCP_CHAN_INFO          => :parent,
                  (略)
            %p
              ちなみにこれをJavascriptで書くとこうなります。
            %pre
              :preserve
                var PacketType = {};
                PacketType[PCP_CONST.PCP_HELO              ]="parent";
                PacketType[PCP_CONST.PCP_OLEH              ]="parent";
                PacketType[PCP_CONST.PCP_CHAN              ]="parent";
                PacketType[PCP_CONST.PCP_CHAN_PKT          ]="parent";
                PacketType[PCP_CONST.PCP_CHAN_INFO         ]="parent";
                (略)
            %p
              PacketTypeはAtomに応じて以下の種類が定義されています。
            %dl
              %dt parent
              %dd このAtomは子Atomを持つAtomです
              %dt byte
              %dd 8ビット符号なし整数を内容とするAtomです
              %dt int
              %dd 32ビット符号なし整数を内容とするAtomです
              %dt short
              %dd 16ビット符号なし整数を内容とするAtomです
              %dt string
              %dd null終端utf-8エンコード文字列を内容とするAtomです
              %dt bytes
              %dd バイト列を内容とするAtomです
              %dt gid
              %dd 16バイトのバイト列を内容とするAtomです。セッションIDなどで使われます。
              %dt ip
              %dd IPアドレスを内容とするAtomです。下位バイトから上位バイトの順に並べられます。
            %p
              Ruby版のYPStandではAtomの内容を取り出したり、あるいは内容を代入したりという操作を
              演算子オーバーロードとして実装していますが、
              Javascriptには演算子オーバーロードは存在しません。
              従って、YPStandJSでは通常の関数によって、Atomの内容を作成したりすることになります。
            %pre
              :preserve
                PCPAtom.prototype.getValue = function() {
                  var type = PacketType[this.name];
                  switch (type) {
                    case undefined:
                    case null:
                      return this.children ? this : this.content;
                      break;
                    case "parent":
                      return this;
                      break;
                    case "byte":
                      return this.content.readUInt8(0);
                      break;
                    case "gid":
                      return new GID(this.content);
                      break;
                    case "int":
                      return this.content.readUInt32LE(0);
                      break;
                    case "ip":
                      var tmpip = Buffer(4);
                      tmpip[3] = this.content[0];
                      tmpip[2] = this.content[1];
                      tmpip[1] = this.content[2];
                      tmpip[0] = this.content[3];
                      return ip.toString(tmpip);
                      break;
                    case "short":
                      return this.content.readUInt16LE(0);
                      break;
                    case "string":
                      return this.content.toString('utf8', 0, this.content.length-1).replace("\u0000", "");
                      break;
                    case "bytes":
                      return this.content;
                      break;
                    default:
                      return new Error("Unknown PacketType: " + type);
                      break;
                  }
                };
                PCPAtom.prototype.setValue = function(v) {
                  var type = PacketType[this.name];
                  switch (type) {
                    case undefined:
                    case null:
                      if (v instanceof Array) {
                        this.children = v;
                      } else {
                        this.content = v;
                      }
                      break;
                    case "parent":
                      this.children = v;
                      break;
                    case "byte":
                      this.content = new Buffer(1);
                      this.content.writeUInt8(v, 0);
                      break;
                    case "gid":
                      this.content = v.id;
                      break;
                    case "int":
                      this.content = new Buffer(4);
                      this.content.writeUInt32LE(v, 0);
                      break;
                    case "ip":
                      var tmpip = ip.toBuffer(v);
                      this.content = new Buffer(4);
                      this.content[0] = tmpip[3];
                      this.content[1] = tmpip[2];
                      this.content[2] = tmpip[1];
                      this.content[3] = tmpip[0];
                      break;
                    case "short":
                      this.content = new Buffer(2);
                      this.content.writeUInt16LE(v, 0);
                      break;
                    case "string":
                      this.content = new Buffer(v + "\0");
                      break;
                    case "bytes":
                      this.content = v;
                      break;
                    default:
                      throw new Error("Unknown packet type: " + type);
                      break;
                  }
                };
                PCPAtom.prototype.getFromName = function(n) {
                  var c = this.children.filter(
                      function(param) {
                        if (n == param.name) {
                          return true;
                        } else {
                          return false;
                        }
                      }
                      );
                  switch (c.length) {
                    case 0:
                      return null;
                      break;
                    case 1:
                      return c[0].getValue();
                      break;
                    default:
                      return c.map(
                          function(param) {
                            return param.getValue();
                          }
                          );
                      break;
                  }
                };
                PCPAtom.prototype.setFromName = function(name, value) {
                  this.children = this.children.filter(
                      function(param) {
                        return (param.name != name);
                      }
                      );
                  var atom = new PCPAtom(name, null, null);
                  atom.setValue(value);
                  this.children.push(atom);
                  return value;
                };
          %p
            Rubyでは[]=演算子のオーバーロードによって、Atomに内容を代入していましたが、
            それに相当するのがsetFromName関数です。
            同じく、Rubyでは[]演算子をオーバーロードすることによって、Atomから内容を取り出していましたが、
            それに相当するのがgetFromName関数です。
            これら2つの関数は両方とも、Atomの子を対象にする関数です。
          %p
            同じくRubyではvalueとvalue=関数を定義することによって、
            Atomの内容を読み出したり、変更したりすることができましたが、
            やはりJavascriptにはそういう機能はないので、
            getValue、setValue関数を定義することで実装しています。
          %p
            これらの関数、特にsetValue関数を実装することにより、
            すぐに送信できるBuffer型として内容を保持しています。
            実際に送信する部分のコードはこのようになります。
          %pre
            :preserve
              PCPAtom.prototype.write = function(stream) {
                if ((this.children != null) && (this.children.length &gt; 0)) {
                  var buf = new Buffer(8);
                  buf.fill(0x0);
                  var c_count = this.children.length;
                  c_count = c_count + 0x80000000;
                  buf.write(this.name, 0);
                  buf.writeUInt32LE(c_count, 4);
                  stream.write(buf);
                  for (var i = 0; i &lt; this.children.length; i++) {
                    this.children[i].write(stream);
                  }
                } else {
                  var buf = new Buffer(8);
                  buf.fill(0x0);
                  buf.write(this.name, 0);
                  buf.writeUInt32LE(this.content.length, 4);
                  buf = Buffer.concat([buf, this.content]);
                  stream.write(buf);
                }
              };
          %p
            つまり、Atomを実際に送信できる形に戻して、stream(例えばsocket)に送信しているわけです。
          %p
            注意したいのはいったん送信用のバッファを0x0で埋めていることです。
            これはJavascriptでnull終端文字列を実現するのが面倒くさいことによります。
            いったんバッファを埋めておかないと、宣言された直後のバッファは不定の値が入るので、
            注意が必要です。
        %section
          %h4 ステート再び
          %p
            さて、これでだいたい下準備は終わりなのですが、またここでステート(状態)管理が登場します。
          %p
            それは何故かというと、先述のPCPハンドシェイクの行う前の段階それぞれで、
            サーバーは状況を判断し状態を保存せねばならず、
            そうしなければブロッキングな処理を行ってしまうことになるからです。
          %p
            PCPハンドシェイクを行う下準備として必要なステートは3種類です。
          %dl
            %dt INITIAL
            %dd 初期状態。まだどんなデータも受け取っておらず、PCPヘッダを待っている状態。'pcp\n'を受け取るとWAITPCPLENGTHに移行する。
            %dt WAITPCPLENGTH
            %dd PCPヘッダのうち、'PCP\n'の部分を受け取り、続くバイト長の部分を待っている状態。バイト長を受け取るとWAITPCPVERSIONに移行する。
            %dt WAITPCPVERSION
            %dd バイト長の部分を受け取り、PCPプロトコルのバージョンを待っている状態。プロトコルバージョンを受け取ると、接続情報を保存してPCPのAtomを送受信できる状態へ移行する。
          %p
            これらのロジックはAtomを読み込むときのロジックとほぼ一緒です。ですが、最後の部分だけがちょっと違います。
        %section
          %h4 接続状態を保存する
          %p
            なぜ接続状態を保存しているのでしょうか。そのひとつはPCPで来る接続とHTTPで来る接続を区別するためです。
          %p
            実はYPのPeercastポートにはPCP以外にもHTTPヘッダが来る場合があります。
            HTTPヘッダはPeercastクライアントがYPに対してピア(リレーの枝)の情報をほしい場合などに送られてきます。
            通常の場合、配信者のアドレスに対してピアの情報を要求するのですが、
            ごくごく希にYPに対して要求してくることがあります。
          %p
            もうひとつの理由は、一度確立された接続を保存することで、コードを分離することができるためです。
        %section
          %h4 RouterとHandler
          %p
            接続状態を保存することによってコードをどのように分離できるか。
            私はHTTPでよく行われる処理を参考に、RouterとHandlerという2つのモジュールに分離しました。
            つまり、メインのコードからRouterに、RouterからHandlerに処理を受け渡すことでコードを分離するのです。
          %p
            Routerのコードを一部示しましょう。
          %pre
            :preserve
              function YpRouter(sock, handlers) {
                
                this.socket = sock;
                this.pcphandler = new handlers["PCP"](this.socket);
                this.httphandler = new handlers["HTTP"](this.socket);
                this.hr = new HeaderReader(sock);
                
                this.route = function(host, chobj) {
                  // route request
                  if (host[this.socket.remoteAddress+":"+this.socket.remotePort]) {
                    if (host[this.socket.remoteAddress+":"+this.socket.remotePort].method == "PCP") {
                      host = this.pcphandler.handle(host, chobj);
                      sock.read(0);
                    } else if (host[this.socket.remoteAddress+":"+this.socket.remotePort].method == "HTTP") {
                      host = this.httphandler.handle(host, chobj);
                      sock.read(0);
                    }
                  } else {
                    req = this.hr.read();
                    try {
                      if (req instanceof PCPRequest) {
                        console.log("Router : Forward to PCP Handler.");
                        host = this.pcphandler.handle(host, chobj);
                        sock.read(0);
                      } else if (req instanceof HTTPRequest) {
                        console.log("Router : Forward to HTTP Handler.");
                        host = this.httphandler.handle(req, host, chobj);
                        sock.read(0);
                      } else {
                        sock.read(0);
                      }
                    } catch (e) {
                      console.log("Router : Exeception detected.");
                      delete host[this.socket.remoteAddress+":"+this.socket.remotePort];
                      this.socket.end();
                    }
                  }
                  return host;
                }
                
              }
          %p
            このように(といってもわかりづらいですが)、ヘッダがPCPなら以降の接続は全てPCP、
            ヘッダがHTTPなら(といってもPCP以外なら全てHTTP扱いをしているのですが)以降の接続は全てHTTPとみなす処理をしています。
          %p
            では次に、PCPのHandlerを見てみましょう。
          %pre
            :preserve
              function PCPHandler(sock) {
                
                this.socket = sock;
                this.reader = new pcpatom.PCPAtomReader(this.socket);
                
                this.handle = function(host, chobj) {
                  if (!(host.sessionId)) {
                    host.sessionId = sessionId;
                  }
                  
                  var data = this.reader.read();
                  if (!(data)) {  // data is null
                    return host;
                  }
                  
                  try {
                    host = processAtom(data, sock, host, chobj);
                  } catch (e) {
                    var quitbuf = new Buffer(4);
                    quitbuf.writeUInt32LE(pcpconst.PCP_ERROR_QUIT+pcpconst.PCP_ERROR_GENERAL, 0);
                    var quitAtom = new pcpatom(pcpconst.PCP_QUIT, null, quitbuf);
                    quitAtom.write(sock);
                    delete host[toStringRemoteAddressPort(sock)];
                    console.log("Handler : Exeception detected ...");
                    console.log(util.inspect(e));
                  }
                  
                  return host;
                }
              }

              exports.Handler = PCPHandler;
          %p
            これも、状態を保存する全てのロジックと同様に、
            コンストラクタ関数からオブジェクトを作成して、その中に全ての状態を保存するようにしています。
          %p
            重要なのはこれらの過程でHost(接続情報)を渡して、Host(接続情報)を返していることです。
            これによって、メインからRouter、そしてHandlerへと行き着く過程の
            全てのオブジェクトで接続情報を共有することができます(泥臭いやり方ですが)。
        %section
          %h4 例外を投げる、捕まえる
          %p
            ところで、ここまでのコードにいくつか<code>try { 文; } catch (e) { 文; }</code>という記述が出てきました。
            勘がよい方はお察しかと思いますが、Javascriptにも例外が存在します。
            例外とは(MDNでは)エラーとも呼ばれており、次の様な形で扱います。
          %pre
            :preserve
              try {
                throw new Error("Error!");
              } catch (e) {
                if (e instanceof Error) {
                  console.log("Error detected" + e.name + ":" + e.message);
                } else {
                  console.log("Unknown error");
                  throw e;
                }
              } finally {
                console.log("Finally.");
              }
          %p
            throwとnew演算子を用いて、新しくエラーオブジェクトを作って例外を投げます。
            そうしてtry節内部で例外が投げられるとcatch節で例外が捕らえられます。
            例外が捕らえられようが捕らえられまいが、最終的にはfinally節が実行されます。
          %p
            例外はとらえられない限り、呼び出し元をさかのぼっていき、
            最終的にcatchされない場合はプログラムを終了させることに注意が必要です。
            つまり、例外が発生する可能性がある場合は、必要に応じて例外を処理しなければなりません。
          %p
            例外についてはやたら深い問題が詰まっているので、他の文献も参照していただけると幸いです。
        %section
          %h4 PCP_HELOを受信して、PCP_OLEHを送り返す
          %p
            ようやくここまで来ました。PCP_HELO Atomを受信して、PCP_OLEH Atomを送り返すコードを見てみましょう。
          %pre
            :preserve
              function onHelo(atom, sock, host, chobj) {
                console.log("Handler : PCP_HELO");
                
                var addr = toStringRemoteAddressPort(sock);
                host[addr] = new PCPHost(
                  atom.getFromName(pcpconst.PCP_HELO_SESSIONID),
                  atom.getFromName(pcpconst.PCP_HELO_BCID),
                  atom.getFromName(pcpconst.PCP_HELO_AGENT),
                  sock.remoteAddress,
                  atom.getFromName((pcpconst.PCP_HELO_PORT || 0)),
                  atom.getFromName(pcpconst.PCP_HELO_VERSION),
                  1  // TODO: Fix Temporary value
                );
                host[addr].method = "PCP";
                host[addr].channelId = [];
                
                var oleh = new pcpatom(pcpconst.PCP_OLEH, [], null);
                oleh.setFromName(pcpconst.PCP_HELO_AGENT, agentName);
                oleh.setFromName(pcpconst.PCP_HELO_SESSIONID, sessionId);
                oleh.setFromName(pcpconst.PCP_HELO_VERSION, 1218);
                oleh.setFromName(pcpconst.PCP_HELO_REMOTEIP, sock.remoteAddress);
                oleh.setFromName(pcpconst.PCP_HELO_PORT, host[addr].port);
                console.log("Handler : Send OLEH");
                
                oleh.write(sock);
                
                return host;
              }
          %p
            最初に説明しておかなければならないのは自作ユーティリティ関数のtoStringRemoteAddressPortですね。
            これはこのようなコードになっています。
          %pre
            :preserve
              function toStringRemoteAddressPort(sock) {
                return sock.remoteAddress + ":" + sock.remotePort;
              }
          %p
            次に説明するべきはPCPHostオブジェクトでしょう。
            これは構造体の代わりをするオブジェクトとして(別ファイルで)定義されています。
          %pre
            :preserve
              function PCPHost(session_id, broadcast_id, agent, ip, port, version, vp_version) {
                this.sessionId = session_id;
                this.broadcastId = broadcast_id;
                this.agent = agent;
                this.ip = ip;
                this.port = port;
                this.version = version;
                this.vpVersion = vp_version;
              }
              exports.PCPHost = PCPHost;
          %p
            このコンストラクタ関数の定義からもわかるように、
            PCP_HELOからはいくつかの情報が読み取れます。
            重要なのは以下です。
          %dl
            %dt セッションID(PCP_HELO_SESSIONID)
            %dd セッションIDは接続ごとに固有に生成されるGIDです。
            %dt ブロードキャストID(PCP_HELO_BCID)
            %dd ブロードキャストIDはクライアント固有のGIDです。YPはこれを用いることはほとんどありませんが、これを利用してクライアントを識別することもできます。
            %dt エージェント(PCP_HELO_AGENT)
            %dd クライアントのエージェント名です。要するにPeercastのリレーにどのソフトウェアを使っているかということです。
          %p
            YPサーバーで作らなければいけない情報もあります。それは配信者のIPアドレスと配信用のポートです。
            これら2つはYP側から教えない限り、ポートが開放されているのか、また、配信用のアドレスがいくつなのかを知ることはできません。
            したがって、YPはこれら2つの情報をPCP_OLEH Atomに含めます。配信用のポートが開いてない場合はポートを0として通知します(だからポート0なのです)。
      %section
        %h3 ひたすらAtomを処理する
        %p この節ではクライアントから送られてくるAtomを処理して、YPに必要な情報を集めていく過程を記述します。
        %section
          %h4 チャンネル情報をどうやって共有するか
          %p 
            処理する前に一番問題となるのはこれです。チャンネル情報は、別のモジュール、
            具体的にはYPで配信されているチャンネルを表示するモジュールと共有しないといけないのです。
            ホスト情報に乗せてもいいのですが、あれは接続ベースなので表示するときに若干困る(チャンネル名から表示したりしたいときなど)のです。
          %p
            ではどうやって共有するのか。このコードを見てもらいましょう。
          %pre
            :preserve
              var util = require('util');
              var pcpconst = require('./peca').PCP_CONST;
              var pcpatom = require('./peca').PCPAtom;

              var chan_list = {};
              function channel() {
              }
              channel.getall = function() {
                return chan_list;
              }
              channel.get = function(chanid) {
                return chan_list[chanid];
              }
              channel.set = function(chanid, obj) {
                chan_list[chanid] = obj;
                // (略、ここでチャンネル情報いろいろ整形してプロパティを作っている)
              }
              channel.del = function(chanid) {
                delete chan_list[chanid];
              }
              exports.channel_mem = channel;
          %p
            このあたりの実装は
            %a{:href=>"https://github.com/dreamerslab/node.secret"}node.secret
            を参考にしています。
            要するに別ファイルでグローバルなオブジェクトを作ってしまって、
            それにアクセスする関数を作ってしまえばよいのです。
            どーせ、チャンネル情報など1つしか持ちませんし。
          %p
            このような実装にする利点はほかにもあります。
            別ファイルに分離しておけば、保存に何を使おうとも、同じ名前の関数を定義しておけば、
            他のファイルでの変更がほぼ不要になるのです。
            これはすばらしい利点です。
        %section
          %h4 PCP_CHAN AtomとPCP_HOST Atomを処理する
          %p
            では次はPCP_BCST Atomの子Atomとして送られてくる、PCP_CHANとPCP_HOSTの各Atomを処理してみましょう。
            具体的なコードはこうなります。
          %pre
            :preserve
              function onChan(atom, sock, host, chobj) {
                console.log("Handler : PCP_CHAN");
                var channelId = atom.getFromName(pcpconst.PCP_CHAN_ID);
                var h = host[toStringRemoteAddressPort(sock)];
                if (!h) {
                  return host;
                }
                var c = chobj.get(channelId.toString());
                if (c) {
                  if (c.broadcastId == h.broadcastId) {
                    var aChInfo = atom.getFromName(pcpconst.PCP_CHAN_INFO);
                    if (aChInfo) {
                      c.info = aChInfo;
                    }
                    var aTrack = atom.getFromName(pcpconst.PCP_CHAN_TRACK);
                    if (aTrack) {
                      c.track = aTrack;
                    }
                    c.lastUpdated = Date.now();
                    chobj.set(channelId.toString(), c);
                  }
                } else if (h.broadcastId) {
                  c = {
                    startFrom : Date.now(),
                    lastUpdated : Date.now(),
                    channelId : channelId,
                    broadcastId : h.broadcastId,
                    info : null,
                    track : null,
                    hosts : {}
                  };
                  chobj.set(channelId.toString(), c);
                  h.channelId.push(channelId);
                }
                return host;
              }

              function onHost(atom, sock, host, chobj) {
                console.log("Handler : PCP_HOST");
                var sId = atom.getFromName(pcpconst.PCP_HOST_ID);
                var channelId = atom.getFromName(pcpconst.PCP_HOST_CHANID);
                var remoteAddr = toStringRemoteAddressPort(sock);
                var hostSId = host[remoteAddr].sessionId;
                var c = chobj.get(channelId.toString());
                if ((hostSId) && (c)) {
                  var hSIdstr = hostSId.toString();
                  var sIdstr = sId.toString();
                  if (hSIdstr == sIdstr) {
                    var hostflag = atom.getFromName(pcpconst.PCP_HOST_FLAGS1);
                    if (!hostflag) {
                      hostflag = 0;
                    }
                    if ((hostflag & pcpconst.PCP_HOST_FLAGS1_RECV) != 0) {
                      c.lastUpdated = Date.now();
                      c.hosts[sId] = atom;
                    } else {
                      delete c.hosts[sId];
                    }
                  }
                }
                return host;
              }
          %p
            PCP_CHAN Atomでは主に配信のメタデータ、具体的には配信名とその説明などが送られてきます。
            同時に、配信を一意に識別するためのGID、チャンネルIDが送られてきます。
            このチャンネルIDを接続情報(Host)に結びつけてやります。
          %p
            PCP_HOST Atomでは主に枝(ピア)に関する情報が送られてきます。
            こちらにも、チャンネルIDが含まれています。
          %p
            落とし穴になるのは、一つのPCP接続から複数の配信を行うことが可能だということです。
            この場合、「全ての配信が終了しない限り」、PCPの切断を行わない為に、PCP_QUIT Atomが送られてきません。
            ですから、一つの接続から複数配信が行われている場合には、YP側で配信終了の判断を行わなければなりません。
            上のコードではこの複数配信の処理を省略しています。
        %section
          %h4 PCP_QUIT Atomを処理する
          %p
            全ての配信を終了し、あとはPCP接続を切断するだけ、となった場合にPeercastクライアントからYPに対して、PCP_QUIT Atomが送られてきます。
          %p
            このAtomが送られてきた場合には、接続情報を調べて、全てのチャンネルを削除し、そして自身を接続情報から削除します。
            具体的なコードを見てみましょう。
          %pre
            :preserve
              function onQuit(atom, sock, host, chobj) {
                console.log("Handler : PCP_QUIT from " + toStringRemoteAddressPort(sock));
                var h = host[toStringRemoteAddressPort(sock)];
                for (var i = 0; i &lt; h.channelId.length; i++) {
                  chobj.del(h.channelId[i]);
                }
                delete host[toStringRemoteAddressPort(sock)];
                var tmpbuf = Buffer(4);
                tmpbuf.writeUInt32LE(pcpconst.PCP_ERROR_QUIT+pcpconst.PCP_ERROR_GENERAL, 0);
                var tmpatom = new pcpatom(pcpconst.PCP_QUIT, null, tmpbuf);
                tmpatom.write(sock);
                sock.end();
                return host;
              }
          %p
            はい、説明通りのコードです。説明していないのは、「おまじない」として接続を切断する前にこちらからもPCP_QUIT Atomを送り返していることくらいです。
      %section
        %h3 YPを表示する
        %p
          この節では、今まで集めた情報を元にして、実際にYPをHTMLやindex.txtとして表示します。
        %section
          %h4 "Express"とは
          %p
            これ以上さらに、フルスクラッチでHTTPサーバーを作るのはしんどいので、今回は非常に便利なフレームワーク、"Express"を使います。
          %p
            %a{:href=>"http://expressjs.com/"}Express
            とは、node.js用に作られた(比較的)軽量なWebフレームワークです。
            RubyにおけるSinatraのちょっと豪華版、だいたいPadrinoあたりの立ち位置と思っていただければいいでしょう(Railsほどは充実していません)。
            公式の例によると、これだけでHTTPのサーバーができてしまいます。
          %pre
            :preserve
              app.get('/hello.txt', function(req, res){
                var body = 'Hello World';
                res.setHeader('Content-Type', 'text/plain');
                res.setHeader('Content-Length', Buffer.byteLength(body));
                res.end(body);
              });
              app.listen(3000);
              console.log('Listening on port 3000');
          %p
            実に簡単です。ですが、Expressはさらに簡単にひな形を作ることもできます。
        %section
          %h4 expressコマンドでひな形を作る
          %p
            まず、公式にもあるとおり、expressモジュールをグローバルにインストールします。
          %pre
            npm install -g express
          %p
            こうすることで、ひな形を簡単に作成できる、expressコマンドを使うことができます。
            使うには<code>express 作成するディレクトリ名</code>とするだけです。
            そうすることで、指定したディレクトリにpackage.jsonをはじめとした様々なディレクトリ、ファイルが作成されます。
        %section
          %h4 package.json
          %p
            ところで、expressコマンドでひな形を作成すると、
            先ほども説明した通り、package.jsonというファイルが作成されます。
            これは、そのアプリケーションに必要なパッケージ、アプリケーションのバージョンと開始方法等を記述したファイルです。
            YPStandJSの場合は以下のようになっています。
          %pre
            :preserve
              {
                "name": "YPStandJS",
                "version": "0.0.1",
                "private": true,
                "scripts": {
                  "start": "node app.js"
                },
                "dependencies": {
                  "express": "3.4.7",
                  "jade": "*",
                  "ip": "*"
                }
              }
          %p
            これを利用することによって、必要なパッケージを一度にインストールすることができます。
            それが<code>npm -d install</code>コマンドです。
            "dependencies"節に書いてあるパッケージを、依存関係を考慮しながらインストールすることができます。
        %section
          %h4 ビューとルート
          %p
            expressを使うためにはビューとルートについて理解しなければなりません。
            ざっくり説明すると、ルートはリクエストを宛先別に振り分けられたあとに実行するもの、
            ビューはそれを受けて表示するものです。
          %p
            なぜこのように分けるのでしょうか。
            それは先の例のように、ソースコードの中に表示する部分を埋め込んでしまうと、
            修正が容易でなくなり、さらには複数人での作業も困難になるためです。
          %p
            では、実際にビューとルートを分けたコードを見てみましょう。
            次に示すのはルートのコードです。
          %pre
            :preserve
              exports.index = function(req, res){
                res.locals.pecaAddr = req.cookies.pecaAddr || '127.0.0.1';
                res.locals.pecaPort = req.cookies.pecaPort || '7144';
                res.render('index', { title: 'YPStandJS' });
              };
          %p
            そして次に示すのがビューのコードです。
          %pre
            :preserve
              extends layout
              block content
                h1= title
                dl
                  - for (var i in channels)
                    - if (channels[i].tracker)
                      dt
                        a(href="http://"+pecaAddr+":"+pecaPort+"/pls/"+channels[i].channelId.toString()+"?tip="+channels[i].tracker)= channels[i].name ? channels[i].name : "名無し"
                      dd
                        dl
                          dt ジャンル
                          - if (channels[i].genre)
                            dd= channels[i].genre
                          dt 最終更新
                          - if (channels[i].lastUpdated)
                            dd= (new Date(channels[i].lastUpdated)).toString()
                          dt リレー
                          - if (channels[i].tracker)
                            dd= channels[i].directs.toString() + " / " + channels[i].relays.toString()
          %p
            今回はビューのコードをJadeというテンプレート専用の言語で書いています。
            ではJadeについて少々解説しましょう。
        %section
          %h4 Jadeを使う
          %p
            %a{:href=>"http://jade-lang.com/"}Jade
            とはNode.js用のテンプレートエンジンです。
            その文法はRuby用のテンプレートエンジン、
            %a{:href=>"http://haml.info/"}Haml
            によく似ており、Hamlを覚えている方なら容易に習得することが可能です。
          %p
            基本はインデントでタグ構造を表現するという、Pythonによく似た文法です。
            文法の詳細は
            %a{:href=>"http://jade-lang.com/reference/"}リファレンス
            にも載っています。
          %p
            重要なのは、<code>-</code>を使うことでJavascriptの文を使うことができるということです。
            これによって、ビューの中でループを使うことができ、記述が非常に楽になります。
            条件判断もすることができるので、例えばユーザーごとに内容を表示しわけたりすることが可能になります。
          %p
            ですが、Jadeの中で外部からのデータを使うには、
            ルートから変数を持ってこなければ使えません。どうやって持ってくるのでしょうか。
        %section
          %h4 ルートからビューに変数を渡すには、あるいはルートミドルウェアとは
          %p
            ルートからビューに変数を渡すこと自体は簡単です。
          %pre
            :preserve
              exports.index = function(req, res){
                res.locals.pecaAddr = req.cookies.pecaAddr || '127.0.0.1';
                res.locals.pecaPort = req.cookies.pecaPort || '7144';
                res.render('index', { title: 'YPStandJS' });
              };
          %p
            これは先に示したコードですが、<code>res.locals</code>に新しくプロパティを追加することによって、
            ビューに変数を渡すことができます。
          %p
            そして地味に面白い仕様として、ルートは数珠つなぎにすることができます。
            これはエントリポイントとなるapp.jsで次の様に書くことで実現されます。
          %pre
            :preserve
              app.get('/', channel_list, routes.index);
          %p
            これはURLの'/'にHTTP GETを結びつけている訳ですが、
            このようにしてルートを数珠つなぎにすると次のコードのような関数を返す関数を使うことによって面白いことができます。
          %pre
            :preserve
              function startPCPServer(port, chobj) {
                var sv = yp.startServer(port, router.YpRouter, handle, chobj);
                var co = chobj;
                return function(req, res, next) {
                  res.locals.channels = co.getall();
                  next();
                }
              }
          %p
            これはYPサーバーをスタートさせる関数ですが、
            その返り値としてreq, res, nextを引数として取る関数を返しています。
            これがポイントです。
            req, res, nextの3つの引数を取る関数ならばどんな関数でも全て数珠つなぎにすることができます。
            これがルートミドルウェアです。
            設定さえしてやればいくつでも数珠つなぎにしてやることができます。
            こうすることによって、実際にページを表示してやるまでに、様々な処理を挟むことができます。
        %section
          %h4 index.txtを作る
          %p
            最後に、index.txtを作って表示してみましょう。
            index.txtの仕様は、元々のYPStandのコードを示すことによって代えさせていただきます。
          %pre
            :preserve
              require 'stringio'
              $server.mount_proc('/index.txt') do |req, res|
                body = StringIO.new
                yp_channles(req).each do |channel|
                  data = [
                    channel.name,       #//1 CHANNEL_NAME チャンネル名
                    channel.channel_id, #//2 ID ID ユニーク値16進数32桁、制限チャンネルは全て0埋め
                    channel.tracker,  #//3 TIP TIP ポートも含む。Push配信時はブランク、制限チャンネルは127.0.0.1
                    u(channel.contact_url),  #//4 CONTACT_URL コンタクトURL 基本的にURL、任意の文字列も可 CONTACT_URL
                    channel.genre,  #//5 GENRE ジャンル
                    channel.description,  #//6 DETAIL 詳細
                    channel.directs.to_s,  #//7 LISTENER_NUM Listener数 -1は非表示、-1未満はサーバのメッセージ。ブランクもあるかも
                    channel.relays.to_s,  #//8 RELAY_NUM Relay数 同上 
                    channel.bitrate.to_s,  #//9 BITRATE Bitrate 単位は kbps 
                    channel.type,  #//10 TYPE Type たぶん大文字 
                    channel.artist,  #//11 TRACK_ARTIST トラック アーティスト 
                    channel.title,  #//12 TRACK_TITLE トラック タイトル 
                    channel.album,  #//13 TRACK_ALBUM トラック アルバム 
                    u(channel.track_url),  #//14 TRACK_CONTACT_URL トラック コンタクトURL 基本的にURL、任意の文字列も可 
                    u(channel.name),  #//15 ENC_CHANNEL_NAME エンコード済みチャンネル名 URLエンコード(UTF-8)
                    channel.uptime,  #//16 BROADCAST_TIME 配信時間 000?99999 
                    'click',  #//17 STATUS ステータス 特殊なステータス disconnectしばらく情報の更新が無い、port0Push配信 又はアイコン
                    channel.comment,  #//18 COMMENT コメント 
                    '0',  #//19 DIRECT ダイレクトの有無 0固定
                  ]
                  body.puts(data.collect {|e| h(e) }.join('&lt;&gt;'))
                end
                res.body = body.string
              end
          %p
            これをそのままJavascriptに移植するとこうなります。
            ビューを使うのはめんどくさいのでそのまま表示させましょう。
          %pre
            :preserve
              exports.index_txt = function(req, res) {
                function escapeBrancket(str) {
                  return str.replace(/&lt;/g, "&amp;lt;").replace(/&gt;/g, "&amp;gt;");
                }
                res.type("text/plain");
                var channels = res.locals.channels;
                var r = ""
                for (var i in channels) {
                  var data = [];
                  data.push(channels[i].name);  // チャンネル名
                  data.push(channels[i].channelId.toString());  // チャンネルID
                  data.push(channels[i].tracker);  // TIP
                  data.push(encodeURI(channels[i].contactUrl));  // コンタクトURL
                  data.push(channels[i].genre);  // ジャンル
                  data.push(channels[i].description);  // 詳細
                  data.push(channels[i].directs.toString());  // リスナー数
                  data.push(channels[i].relays.toString());  // リレー数
                  data.push(channels[i].bitrate.toString());  // ビットレート
                  data.push(channels[i].type);  // 配信種別
                  data.push(channels[i].artist);  // トラックアーティスト
                  data.push(channels[i].title);  // トラックタイトル
                  data.push(channels[i].album);  // トラックアルバム
                  data.push(encodeURI(channels[i].trackUrl));  // トラックのコンタクトURL
                  data.push(escapeBrancket(encodeURI(channels[i].name)));  // チャンネル名
                  var uptime = channels[i].lastUpdated - channels[i].startFrom;
                  var uptimeHour = Math.floor(uptime / (1000 * 60 * 60));
                  var uptimeMin = Math.floor(uptime / (1000 * 60));
                  data.push(uptimeHour.toString() + ":" + uptimeMin.toString());  // 配信時間
                  data.push("click");  // ステータス
                  data.push(escapeBrancket(channels[i].comment));  // コメント
                  data.push("0"); // ダイレクトの有無
                  r = r + data.join("&lt;&gt;") + "\n";
                }
                res.send(r);
              }
  %section
    %h2 あとがき
    %p
      これで、一通り、本当に本当に基本的な機能を持ったYPができあがりました。
    %p
      ですが、このYPにはまだまだバグもあり、機能も足りていません。
      しかしながら、YPStandJS作成を通して、ある程度はJavascriptを知ることができたと言え、
      その意味では収穫があったと言えるでしょう。
    %p
      最後にこの文章が皆さんの役に立ち、Peercastコミュニティの活性化に役立つことを祈ります。
