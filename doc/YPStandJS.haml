-# vim: fileencoding=utf-8
!!! 5
%html
  %head
    %title YPを作って学ぶJavascript
    %meta{"http-equiv"=>"content-type", :content=>"text/html; charset=utf-8"}
  %body
    %section
      %h1 YPを作って学ぶJavascript
      %section
        %h2 前書き
        %section
          %h3 この文書について
          %p
            この文書はnode.jsを使ってJavascriptを勉強し始めたど素人が、
            YPを作ることによっていろいろ学習していく過程をまとめたものです。
          %p
            もしも、この文書が、何かのお役に立つなら幸いです。
        %section
          %h3 注意点
          %p
            この文書はあくまでも一人の主観と独学によって書かれています。
            したがって、Javascriptやnode.jsの一般的なセオリーから外れていることが多いかもしれません。
            もし、そのようなことがあったり、あるいは何らかの間違いがあったとしても、ご笑覧いただければと思います。
      %section
        %h2 node.jsで遊ぼう
        %p
          この章ではnode.jsの紹介と導入、そして簡単なJavascriptプログラムについて学習します。
        %section
          %h3 node.jsとは何か
          %p
            これからYPを作るにあたって、
            node.jsというソフトを使っていくわけですが、
            簡単にこのソフトを紹介したいと思います。
          %p
            node.jsはChromeのJavascriptエンジン(V8エンジンと呼ばれています)を使った、
            軽量でありかつ高速にネットワークアプリケーションを動かすためのプラットフォームです。
            その性能は
            %a{:href=>"http://nodejs.org/industry/"}多数の企業で使われている
            ことからも折り紙付きといえるでしょう。
          %p
            大きな特徴は、イベント駆動であり、ノンブロッキングでほぼすべての動作が実行されるということです。
            この特徴はプログラムを作る際に大きく関わってくるので、また後ほど説明します。
        %section
          %h3 node.jsのダウンロードとインストール
          %p WindowsでもMacでもインストールは簡単です。
          %p
            %a{:href=>"http://nodejs.org/download/"}公式のダウンロードページ
            にインストーラがあるのでそれをダウンロードして実行するだけです。
            もちろん、Windowsの場合には管理者権限など考慮することをお忘れなく。
          %p
            Linux用のバイナリも配布されていますが、
            ディストリビューションで用意されてるパッケージマネージャを使う方が無難でしょう。
        %section
          %h3 npmとは
          %p
            npmとはnode.js専用のパッケージマネージャです。
            Rubyに親しみがある人ならgem、
            Pythonに親しみがある人ならpipと言えばわかるでしょうか。
            これを使うことによって、簡単に依存関係を意識することなく、パッケージを導入することができます。
          %p
            なお、Windowsのインストーラを使った場合、npmを使う際には若干落とし穴があります。
            それは環境変数
            %code NODE_PATH
            を設定することです。
            具体的には
            %a{:href=>"http://sucrose.hatenablog.com/entry/20120315/p1"} このページあたり
            を参照するとよいでしょう。
        %section
          %h3 node.jsを動かしてみる
          %p
            インストールは出来ましたか？
            ではnode.jsを動かしてみましょう。
          %figure
            %img{:src=>'./img/nodejs_initial.jpg'}
            %figcaption
              node.js(node.exe)起動時の画面
          %p
            node.jsは何も指定せずに起動すると、
            このように単純な画面が表示されます。
            Pythonのそれ、もしくはRubyのirbと似たようなものだと思っていただけるといいです。
          %p
            では、最初のお約束、"Hello, World!"を表示させてみましょう。
          %figure
            %img{:src=>'./img/nodejs_console_hello.jpg'}
            %figcaption
              node.jsで"Hello, World!"
          %p
            簡単ですね？
            コンソールを終了させるには、(Windowsの場合)CTRL+Cを2回押してください。
          %figure
            %img{:src=>'./img/nodejs_console_quit.jpg'}
            %figcaption
              node.jsを終了させる
        %section
          %h3 Hello,World! プログラム
          %p
            この節ではHello, World!プログラムを書くことで、
            簡単にJavascriptを紹介していきます。
          %section
            %h4
              %abbr{:title=>'Mozilla Developer Network'}MDN
              のJavascriptガイドとリファレンス
            %p
              これからJavascriptの説明などをしていくわけですが、
              その前にいくつかリファレンスの紹介をしていきたいと思います。
            %p
              まずはJavascript自体のリファレンスですが、
              これはMDNの
              %a{:href=>'https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide'}ガイド
              と
              %a{:href=>'https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference'}リファレンス
              が非常によい資料になると思います。
              正確にはJavascriptというより、
              ECMAScriptの資料なのですが、
              ブラウザごとの対応状況も載ってたりするなど非常に詳しいものです。
          %section
            %h4
              node.jsのAPIリファレンス
            %p
              node.jsにもリファレンスは提供されています。
              %a{:href=>'http://nodejs.org/api/'}これがnode.jsのAPIリファレンス(英語)
              です。
              %a{:href=>'http://nodejs.jp/nodejs.org_ja/api/'}有志による日本語リファレンス
              も整備されています。
            %p
              node.jsのプログラムを読み進める時、書いていく時には
              これらの文書に頼ると非常にはかどることでしょう。
          %section
            %h4
              関数の書き方
            %section
              %h5 名前あり関数
              %p
                では実際に"Hello, World!"プログラムを書いてみましょう。
                今度のプログラムは以前とは少々違うものです。
                次のコードをあなたのお好みのテキストエディタで打ち込み、
                文字コードをUTF-8にして保存してください。
              %pre
                :preserve
                  function printHello() {
                    console.log("Hello, World!");
                    return;
                  }
                  printHello();
              %p
                私はこのプログラムをfunchello.jsという名前で保存しました。
                では、実際に実行してみましょう。
              %figure
                %img{:src=>'./img/funchello.jpg'}
                %figcaption
                  funchello.jsを実行した様子
              %p
                期待した通りの結果が出たと思います。
                Javascriptでは関数を
                %code function 名前(引数1, 引数2, ...) { 文; }
                という形で定義します。
            %section
              %h5 無名関数(あるいはすべてがオブジェクトということ)
              %p 今度は次のコードを実行してみてください。
              %pre
                :preserve
                  var hello = function(v) {
                    console.log(v);
                    return;
                  };
                  hello("Hello, World!");
              %figure
                %img{:src=>'./img/funchello2.jpg'}
                %figcaption
                  やっぱり同じ結果になる
              %p
                このように同じ結果になったと思います。
                Javascriptでは(宣言しなくても使えますが)、
                変数を
                %code var 変数名 = 変数の中身;
                というようにして宣言しますが、
                では変数helloに入れられているものは何でしょうか。
              %p
                それはもちろん関数です。
                Javascriptでは関数もオブジェクトであり、
                関数は名前を書かなくても宣言できるのです。
                オブジェクトを宣言するにはどうするのか、ということについては、
                ずっと後のほうで説明します。
            %section
              %h5 関数を返すということ
              %p
                ついてこれているでしょうか？
                今度はかなり変わった形で、やはり同じ結果を出力するプログラムを書きます。
              %pre
                :preserve
                  function print(v) {
                    return function() {
                      console.log(v);
                    };
                  }
                  var hello = print("Hello, World!");
                  hello();
              %p 実行してみましょう。
              %figure
                %img{:src=>'./img/funchello3.jpg'}
                %figcaption
                  関数をもらって実行する
              %p
                理解できたでしょうか？
                関数の中で、渡された引数を使う関数を返しています。
                こういうテクニックはちょくちょく使われることがあるので、
                覚えておくと若干幸せになれます。
                もっと詳しく知りたい方は
                %a{:href=>'https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Closures'}MDNガイドの「クロージャ」
                を見てみるとよいでしょう。
            %section
              %h5 モジュールをエクスポートする、そして使う
              %p
                では今度は次のコードをfunchello4.jsという名前で保存してください。
              %pre
                :preserve
                  function printHello() {
                    console.log("Hello, World!");
                  }
                  exports.printHello = printHello;
              %p
                これを直接実行しないでくださいね？
                これを保存したディレクトリに移動して、node.jsを起動してみて、
                次のように入力してみてください。
                先頭の
                %code &gt;
                はnode.jsのプロンプトです。
              %pre
                :preserve
                  > var funchello4 = require('./funchello4');
                  > funchello4.printHello();
              %figure
                %img{:src=>'./img/funchello4.jpg'}
                %figcaption
                  エクスポートして他のところで使う例
              %p
                この例でわかるように、
                %code exports.オブジェクト名 = 外に出したいオブジェクト;
                とすることで、他のファイルから関数などを使うことができます。
              %p
                逆に使いたいファイルからは、
                %code var 変数名 = require('使いたいモジュール');
                とすることで、以降、
                %code 変数名.エクスポートされたオブジェクト
                という形で使うことができます。
      %section
        %h2 YPStand(YP大地に立つ)について
        %p
          この章では、YPStand(YP大地に立つ)を解析することで、
          YP実装に必要なPCPプロトコルを解説します。
        %section
          %h3 そもそもYPStand(YP大地に立つ)とは何か
          %p
            YPStand(もしくはYP大地に立つ、以下YPStand)とは、あれくまさんが作った、
            Peercast本体を使わない、簡易YPサーバーです。
            Peercast本体を使わず、しかもRubyで書かれたソースが添付されているので、
            YPに必要なPCPプロトコルを簡単に解析することができます。
        %section
          %h3 YPStandソースのざっくりした解説
          %section
            %h4 ソースを読む、その前に
            %p
              YPStandはRubyで書かれています。
              ですから、読む側にはある程度Rubyの知識が必要です。
              お手元に
              %a{:href=>'http://docs.ruby-lang.org/ja/2.1.0/doc/index.html'}Rubyのリファレンス
              を用意してお読みください。
              Rubyがわからない場合は、後ろの方でPCPプロトコルについてまとめてありますので、
              そちらまで飛ばしてもかまいません。
          %section
            %h4 初めはエントリポイントから
            %p
              YPStandはypstand.rbがエントリポイント(プログラムの開始時点)になります。
              その中で重要なのは以下の行です。
            %pre
              :preserve
                $root = PCPRootServer.new(
                  Settings['BindAddress']    || '0.0.0.0',
                  Settings['PCPPort']        || 7144,
                  Settings['AgentName']      || 'YPStand',
                  Settings['MaxConnections'] || 64
                )
            %p
              これは
              %code $root
              というグローバル変数(Rubyでは$で始まる変数はグローバル変数です)に、
              PCPRootServerのインスタンスを作成して代入しています。
              %code ||
              は
              %code 1 || 2
              と書かれた場合、1が真ならば1、そうでないならば2という演算子です(この演算子はJavascriptでも使えます)。
            %p
              ではこのPCPRootServerはどこで定義されているのでしょうか。
              それは頭のrequireを見ていけばわかります。
            %pre
              :preserve
                require 'yaml'
                require 'webrick'
                require 'ypstand/yp'
                require 'ypstand/channelinfo'
                require 'ypstand/utils'
            %p
              結論から言うと、PCPRootServerは
              %code ypstand/yp.rb
              で定義されています。
              ではそのファイルを見ていきましょう。
          %section
            %h4 PCPRootServerでの処理の流れ
            %p
              PCPRootServerは標準添付ライブラリgserverを用いて実装されています。
              gserverの使い方は
              %a{:href=>'http://docs.ruby-lang.org/ja/2.1.0/library/gserver.html'}Rubyのgserverの項
              を見ればすぐにわかるかと思います。
              一番最初に見るべきは、関数serveです。
            %pre
              :preserve
                def serve(sock)
                  request = read_header(sock)
                  case request
                  when PCPRequest
                    process_client_pcp(request, sock)
                  when HTTPRequest
                    process_client_http(request, sock)
                  else
                    #Do nothing
                  end
                end
            %p
              PCPに関する流れだけ見ると、これは簡単で、
              <code>read_header</code>を呼び出して、
              もらったヘッダ部分を<code>process_client_pcp</code>に渡しています。
              最初に<code>read_header</code>を見ていきましょう。
            %pre
              :preserve
                def read_header(io)
                  header = io.read(4)
                  if header=="pcp\n" then
                    len = io.read(4).unpack('V')[0]
                    raise "Length Error" unless len==4
                    PCPRequest.new(io.read(4).unpack('V')[0])
                  else
                    until /\r\n\r\n$/=~header do
                      header &lt;&lt; io.read(1)
                    end
                    parse_http_header(header)
                  end
                end
            %p
              まず最初にソケット(ネットワーク)から4バイトだけ読み込みます。
              それが<code>pcp\n</code>(\nは改行文字)だったら、さらに4バイト読み込みます。
            %p
              <code>unpack</code>はRuby特有の機能かつ、PCPを見ていく上でも重要なので、
              %a{:href=>'http://docs.ruby-lang.org/ja/2.1.0/class/Array.html#I_PACK'}リファレンスのテンプレート文字列
              の項を見ながら説明していきます。
              <code>unpack</code>は(バイナリ)文字列を配列に変換するインスタンスメソッド(関数)です。
              この場合は<code>V</code>1文字なので、リトルエンディアンの符号なし32ビット整数を表しています。
              PCPで他によく使われるフォーマット文字列は他に<code>C*</code>(任意長の8ビット符号なし整数)、
              <code>Z4</code>(空きにnull文字(\0)を詰めた4文字の文字列)などがあります。
            %p
              つまり、ヘッダの部分をバイト列で表すとこうです。
            %pre
              :preserve
                PPPPLLLLVVVV
            %p
              Pの部分にはPCPプロトコルを表すヘッダ、<code>"pcp\n"</code>が入ります。
              その次のLの部分は、続くデータのバイト長をリトルエンディアン32ビット整数で表したものが入ります。
              なお、ヘッダの場合はここは常に4であることが想定されます。
              最後のVの部分、これはPCPのプロトコルバージョンを表しています。
              やはりこれもリトルエンディアン32ビット整数です。
              なお、後からわかりますが、現行のPeercastではこれも常に1です。
            %p
              では次に、<code>process_client_pcp</code>を見てみましょう。
            %pre
              :preserve
                def process_client_pcp(request, sock)
                  raise PCPError.new('Unknown PCP Version', PCP_ERROR_QUIT+PCP_ERROR_GENERAL) unless request.version==1
                  helo = PCPAtom.read(sock)
                  raise PCPError.new('Handshake failed', PCP_ERROR_QUIT+PCP_ERROR_GENERAL) unless helo.name==PCP_HELO
                  host = on_helo(sock, helo)
                  until @closed do
                    if IO.select([sock], [], [], 0.1) then
                      process_atom(sock, host, PCPAtom.read(sock))
                    end
                  end
                  PCPAtom.new(PCP_QUIT, nil, [PCP_ERROR_QUIT+PCP_ERROR_SHUTDOWN].pack('V')).write(sock)
                rescue PCPError => e
                  PCPAtom.new(PCP_QUIT, nil, [e.quit].pack('V')).write(sock)
                rescue PCPQuitError
                ensure
                end
            %p
              エラー処理の部分を除くと、そんなに難しいことはありません。
              ソケットからAtomを読み取って、HELOを処理して、あとは接続が切断されるまで延々とAtomを読み取って処理しているだけです。
              ってわかるわけないですよね？
            %p
              PCPAtomクラスのread関数を見てみましょう。
              これは<code>ypstand/peca.rb</code>で定義されています。
            %pre
              :preserve
                def self.read_blocking(stream, sz)
                  buf = stream.read(sz)
                  if buf then
                    while buf.bytesize&lt;sz do
                      res = stream.read(sz-buf.bytesize)
                      break unless res
                      buf &lt;&lt; res
                    end
                  end
                  buf
                end
                def self.read(stream)
                  buf = self.read_blocking(stream, 8)
                  if buf then
                    cmd, len = buf.unpack('Z4V')
                    if (len & 0x80000000)!=0 then
                      children = len & 0x7FFFFFFF
                      self.new(cmd, Array.new(children) { read(stream) }, nil)
                    else
                      self.new(cmd, nil, self.read_blocking(stream, len))
                    end
                  else
                    nil
                  end
                end
            %p
              <code>buf = self.read_blocking(stream, 8)</code>の部分から、
              PCPプロトコルのヘッダは常に8バイト区切りということがわかります。
              問題は<code>cmd, len = buf.unpack('Z4V')</code>の部分です(実は他にもread_blockingの部分には問題が隠されているのですがそれは後ほど)。
            %pre
              :preserve
                CCCCLLLL
            %p
              ここは最初の8バイトを先のように分割しています。
              <code>C</code>の部分はコマンド文字列(空きはnull文字で埋め)、
              <code>L</code>の部分はこの次に続く内容のバイト長を表しています。
              が、ちょっとここは特殊です。
              <code>L</code>の部分をビットで表してみると次のようになります。
            %pre
              :preserve
                ←上位                       下位→
                HLLLLLLL|LLLLLLLL|LLLLLLLL|LLLLLLLL
                |は8ビットごとの実際にはない区切り
            %p
              <code>H</code>のビットが重要です。
              このビットが立っていた場合、H以外のビットで、
              このAtomの次に子Atomがいくつ続くかを表しています。
              単位は個数です。次に出てくるヘッダでまた同じようなことを繰り返します。
            %p
              では、
              %code ypstand/yp.rb
              の<code>process_client_pcp</code>に戻って続きを見ていきましょう。
              次に出てくるのはこの行です。
            %pre
              :preserve
                host = on_helo(sock, helo)
            %p
              問題のon_helo関数を見てみましょう。
            %pre
              :preserve
                def on_helo(sock, atom)
                  host = Host.new
                  host.session_id   = atom[PCP_HELO_SESSIONID]
                  host.broadcast_id = atom[PCP_HELO_BCID]
                  host.agent        = atom[PCP_HELO_AGENT]
                  host.ip           = sock.peeraddr[3]
                  host.version      = atom[PCP_HELO_VERSION]
                  if atom[PCP_HELO_PING] then
                    host.port = pcp_ping(host.session_id, sock.peeraddr[3], atom[PCP_HELO_PING])
                  else
                    host.port = atom[PCP_HELO_PORT] || 0
                  end
                  oleh = PCPAtom.new(PCP_OLEH, [], nil)
                  oleh[PCP_HELO_AGENT]     = @agent_name
                  oleh[PCP_HELO_SESSIONID] = @session_id
                  oleh[PCP_HELO_VERSION]   = 1218
                  oleh[PCP_HELO_REMOTEIP]  = sock.peeraddr[3]
                  oleh[PCP_HELO_PORT]      = port
                  oleh.write(sock)
                  host
                end
            %p
              <code>pcp_ping</code>を除けば、やっていることはそこまで難しくありません。
              PCP_HELOというAtomの子Atomから必要な情報を保存し、
              PCP_OLEHというAtomを作って、クライアントに送信しているわけです。
              このHELOを受け取ったらOLEHを返すという流れは非常に重要です。
            %p
              <code>on_helo</code>の次は<code>process_atom</code>です。
              コードを以下に示します。
            %pre
              :preserve
                def process_atom(sock, host, atom)
                  return unless atom
                  case atom.name
                  when PCP_BCST; on_bcst(sock, host, atom)
                  when PCP_HOST; on_host(sock, host, atom)
                  when PCP_CHAN; on_chan(sock, host, atom)
                  when PCP_QUIT; on_quit(sock, host, atom)
                  end
                end
            %p
              ソースを見てもらうとわかりますが、
              PCP_HOSTとPCP_CHANというAtomにはチャンネルの情報が含まれています。
              そして、予想されるとは思いますが、配信が終了すると、PCP_QUITというAtomが送信されてきます。
            %p
              これで、おおよそ、YPStandの解説は終わりです。
              ではPCPの仕様をまとめてみましょう。
        %section
          %h3 YPStandからわかるPCPプロトコル仕様
          %p
            この節では、YPに必要なだけのPCPプロトコル仕様を解説します。
          %section
            %h4 PCPパケットの構造
            %p
              PCPパケットはヘッダとコンテンツの2つの部分に分かれており、
              ヘッダは次のような構造をしています(1文字=1バイト/オクテット)。
            %pre
              :preserve
                CCCC1234
            %p
              <code>C</code>の部分はnull文字(\0)で空きが埋められたコマンド文字列です。
              たとえばPCP_HELOというAtomの場合、ここには<code>helo</code>という文字列が、
              PCP_QUITの場合、<code>quit</code>という文字列が入ります。
            %p
              <code>1234</code>の部分はリトルエンディアン32ビット符号なし整数で表現された、
              コンテンツの長さ(バイト単位)、あるいは子Atomの個数を表します。
              リトルエンディアンなので、十進数の<code>1</code>を表すと、
              <code>0x1,0x0,0x0,0x0</code>のような並び順になります。
              重要なのは(順番を元通りにした後の)最上位ビットの扱いで、
              最上位ビットが1の場合、残りのビットで子Atomの個数を表すということです。
              この場合、このヘッダの直後に子Atomのヘッダ(とその中身)が入れ子のように表れます。
          %section
            %h4 YPとやりとりされるデータの流れ
            %p
              では実際にYPとデータをやりとりする流れを見てみましょう。
            %ol
              %li
                %dl
                  %dt (クライアント)PCPプロトコルヘッダとバージョンをYPに送出する
                  %dd
                    まず、クライアントはYP側(サーバー)にPCPバージョンを含んだヘッダを送出します。
                    これによってサーバーはPCPプロトコルであることを認識します。
                  %dd
                    %pre
                      :preserve
                        参考:
                        |p|c|p|\n|0x4|0x0|0x0|0x0|0x1|0x0|0x0|0x0|
                        |command |内容長         |バージョン     |
              %li
                %dl
                  %dt (クライアント)PCP_HELOをサーバーに送出する
                  %dd
                    クライアントはPCP_HELO('helo')コマンドと必要な情報をサーバーに送出します。
                    この情報にはブロードキャストID、
                    セッションID、使っているクライアント名などが含まれます。
              %li
                %dl
                  %dt (サーバー)PCP_OLEHをクライアントに送出する
                  %dd
                    サーバーはクライアントの(サーバー側から見たときの)IPアドレス、
                    (クライアントの配信用)ポート、
                    そして自身のクライアント名などを含んだ情報を含む
                    PCP_OLEH('oleh')コマンドをクライアントに送出します。
                    なお、この際にポートが0であった場合、
                    それはクライアントの配信用ポート(例:7144)が開いていないことを意味します。
                  %dd
                    PCP_HELOとPCP_OLEHを送り合うこのやり方をPCPハンドシェイクと呼称することがあります。
                    これはサーバー側からクライアントのポートの開放確認の際にも行われます。
                    ちなみにこれから作るYPではこの解放確認処理は省略します。
              %li
                %dl
                  %dt (クライアント)定期的にもしくは情報変更時にPCP_BCSTを送信する
                  %dd
                    クライアントは定期的に、あるいは自身の配信情報などが変更された際に、
                    PCP_BCST('bcst')コマンドをサーバーに送出します。
                    これはいわゆるKeep-Aliveの役目も果たします。
                    PCP_BCSTの中に含まれるAtomの中で重要なものは以下の2つです。
                  %dd
                    %dl
                      %dt PCP_CHAN('chan')
                      %dd
                        このAtomの中には自身のチャンネルID、
                        流している配信のビットレート、ジャンル、タイプなどが含まれます。
                      %dd
                        PCP_CHANで流れる情報の中で最も重要なのは「チャンネルID」です。
                        PeercastクライアントはこのチャンネルIDと配信者IPアドレスによって、
                        Peercastのリレーを確立します。
                      %dt PCP_HOST('host')
                      %dd
                        このAtomの中にも自身のチャンネルIDが含まれ、
                        他にブロードキャストID、自身のリレー数とリスナー数などが含まれます。
                      %dd
                        こちらはいわゆる自身の「枝」の情報が含まれています。
                        説明を見ればわかるとおり、「リスナー数は自己申告」です。
              %li
                %dl
                  %dt (クライアント/サーバー)配信/YPを終了する際にPCP_QUITを送信する
                  %dd
                    最終的に配信/YPを終了する際には、PCP_QUIT('quit')を相手側に送信します。
                    このAtomにはどのような理由で接続を終了するかのフラグが含まれます。
                  %dd
                    このAtomを送出せずに落ちた場合、相手側にゴミが残る場合があります。
                    なるべくなら送出してから接続を切断しましょう。
      %section
        %h2 YPStandJSを作る
        %p この章では、実際にnode.jsとJavascriptを使って、YPStandのJavascript移植版、YPStandJSを作ります。
        %section
          %h3 パケットを読むだけのサーバーを作る
          %p この節では、実際にYPStandJSを作る前段階として、パケットを読み取るだけのサーバーを作ります。
          %section
            %h4 ソースコード紹介
            %p
              では実際に動くソースコードを見てみましょう。
            %pre
              :preserve
                var net = require("net");
                var util = require("util");
                var sv = net.createServer(
                  function(s) {
                    s.on("readable",
                      function() {
                        var d = s.read();
                        if (d != null) {
                          console.log(util.inspect(d));
                        }
                      }
                    );
                  }
                );
                sv.listen(7146,
                  function() {
                    console.log("Sever listen on port 7146.");
                  }
                );
            %p
              短いコードですが、このコードにはnode.jsを理解するための基本が詰まっています。
          %section
            %h4 node.jsのイベントシステム
            %p
              node.jsはイベント駆動/ノンブロッキング入出力が特徴、と以前解説しました。
              ここではその詳細について解説します。
            %section
              %h5 イベント駆動の考え方
              %p
                node.jsではイベント駆動という考え方を採用しています。
                これは、node.jsがシングルスレッドで動いていることが大きいと理解しています。
              %p
                たとえば、ファイルの読み込みを考えてみましょう。
                ファイルの読み込みは時間のかかる処理です。
                node.jsはシングルスレッドで動いているために、
                ファイルの読み込みが完了するまで待つと他の処理まで止まってしまいます。
                ですから、その代わりにこうします。
                「ねぇ、ファイルの読み込みが終わったら、この関数を呼んでよ」、と。
                つまり、「ファイルの読み込みが終わった」というイベントに対して、「関数を呼ぶ」。
                これがイベント駆動です。
            %section
              %h5 ブロッキングとノンブロッキング
              %p
                ではブロッキングとノンブロッキングについて説明します。
              %p
                まず初めにブロッキングという概念を説明しましょう。
                これは「ある処理が終わるまで他の処理をしないで待つ」ということです。
                当然これでは、(マルチスレッドで処理をしない限り)他の処理を並行して行うことができません。
                たとえば、Webサーバーだったとしたら、複数ユーザーのリクエストを並行して受け付けることができないわけです。
              %p
                ではそれに対してノンブロッキングとは何かということを説明します。
                ノンブロッキングとは(イベント駆動の説明とかぶる部分もありますが)、
                「ある処理を受け付けたら、結果は後で返す」ということです。
                この「結果は後で返す」間に他の処理を挟むことが出来ます。
                つまり、Webサーバーの例ならば、他のユーザーからのリクエストも並行して受け付けられるわけです。
          %section
            %h4 ソースコードの分解/解説
            %p では先のソースコードをもっとわかりやすい形に分解してみましょう。
            %p
              無名関数は有名関数に置き換えることができます。たとえばこのような形に。
              ですが、すべての無名関数をこのように書き換えることができるわけではありません。
            %pre
              :preserve
                var f = function() {
                  console.log('Hello!');
                }
            %pre
              :preserve
                function hello() {
                  console.log('hello!');
                }
                var f = hello;
            %p
              つまり、先のソースコードはこのような形でも書けます。
            %pre
              :preserve
                var net = require("net");
                var util = require("util");
                function onConnection(socket) {
                  socket.on("readable",
                    function() {
                      data = socket.read();
                      if (data != null) {
                        console.log(util.inspect(data));
                      }
                    }
                  );
                }
                function onListening() {
                  console.log("Server listening.");
                }
                var server = net.createServer(onConnection);
                server.listen(7146, onListening);
            %p
              若干わかりやすくなったでしょうか？では解説していきましょう。
            %p
              1行目と2行目は必要なモジュールをrequireしています。
              <code>net</code>はネット関連のライブラリ、具体的にはサーバーとソケットを扱うライブラリが集まっています。
              <code>util</code>はnode.jsをデバッグしたりするときに便利なライブラリが集まっています。
            %p
              関数onConnectionとonListeningを飛ばして、
              先の方を見てみましょう。<code>net.createServer(onConnection)</code>とあります。
              <code>net.createServer</code>はTCPでの接続を受け入れるサーバーインスタンスを作成します。
              ではこれに渡されている関数onConnectionは何でしょうか。
              これは
              %a{:href=>"http://nodejs.org/api/net.html#net_event_connection"}"connection"イベント
              が起こった時に呼ばれる関数です。"connection"イベントが起こると、
              "Socket"オブジェクトを引数として関数が呼ばれます。
            %p
              そして、<code>server.listen(7146, onListening)</code>です。
              これは7146番ポートでサーバーの待ち受けを開始させます。
              onListening関数は"listening"イベント、つまり、待ち受けの準備が整った時に送出されるイベントです。
              node.jsはほぼすべてがノンブロッキングで実行されるので、
              <code>server.listen</code>が実行されても、すぐには待ち受けが開始されないのです。
            %p
              onConnection関数の中身を見ていきましょう。
          %section
            %h4 on(とonce)でイベントにつながる
            %p
              onConnection関数だけをもう一度抜粋します。
            %pre
              :preserve
                function onConnection(socket) {
                  socket.on("readable",
                    function() {
                      data = socket.read();
                      if (data != null) {
                        console.log(util.inspect(data));
                      }
                    }
                  );
                }
            %p
              2行目で<code>socket.on("readable", 関数)</code>ということをしています。
              これは何でしょうか。
            %p
              node.jsでは多くのオブジェクトがイベントを送出する"EventEmitter"です。
              EventEmitterには<code>オブジェクト.on("イベント名", 関数)</code>という形で
              イベントに連動して呼び出される関数を指定することができます。
              onにはもう一つ派生があってonceというのがあります。
              <code>オブジェクト.once("イベント名", 関数)</code>という形になります。
              こちらはイベントが発生したら「1回だけ」関数が呼び出されます。
              名前通りですね。
          %section
            %h4 バイナリを扱うBuffer型
            %p
              こんどは無名関数のところだけを抜粋します。
            %pre
              :preserve
                function() {
                  data = socket.read();
                  if (data != null) {
                    console.log(util.inspect(data));
                  }
                }
            %p
              socketはconnectionイベントで渡されるソケットオブジェクトです。
              そして、インスタンスメソッドのreadは任意の長さのデータを読み出す関数です。
              ここでは長さが指定されていないので、読み込めるだけすべてのデータを読み出しています。
              なお、読み出せないときには、この関数はnullを返します。
              長さが指定されているときにその長さが読み込めないときもnullを返します。
            %p
              では実際にデータを受け取って見ましょう。
              データを流してもらう相手はPeercastStationを使います。
            %p
              まずは次のような形で新規YPを追加してください。
            %figure
              %img{:src=>'./img/pecast_addyp.jpg'}
              %figcaption
                PeercastStationに新規YPを追加する
            %p
              そして次に、先ほどのプログラムをnode.jsで動かします。
            %figure
              %img{:src=>'./img/packetcapture_initial.jpg'}
              %figcaption
                パケットキャプチャを動かす
            %p
              最後に、node.jsで待ち受けしているポート(YP)に対して、配信を開始します。
              配信ソースは用意しなくてもかまいません。
            %figure
              %img{:src=>'./img/pecast_broadcast.jpg'}
              %figcaption
                配信設定の一例
            %figure
              %img{:src=>'./img/packetcapture_broadcast.jpg'}
              %figcaption
                配信をしてみた際のnode.jsの画面
            %p
              終わる時はnode.jsの画面でCTRL+C、そして、PeercastStation側で通常通り配信を終了させてください。
            %p
              では、このnode.js側の結果について解説していきます。
              <code>util.inspect(オブジェクト)</code>はオブジェクトを見やすい形式の文字列に変換する関数です。
              これは非常に便利なのでよく使います。
              ですが、整形された結果の<code>&lt;Buffer なんちゃらかんちゃら&gt;</code>とはなんでしょうか。
            %p
              これはnode.js特有の
              %a{:href=>'http://nodejs.org/api/buffer.html'}Buffer型
              と呼ばれるものです。
              Javascriptは文字列処理に関しては非常に優秀ですが、
              バイナリデータの処理に関しては貧弱です。
              それを補うためにBuffer型が作られているのです。
            %p
              Buffer型は基本的にバイト単位でデータを扱います。
              性質は配列によく似ており、<code>[]</code>を使うことや、
              <code>buf.length</code>で長さを参照することもできます。
              一番の特徴は、ネットワークなどでデータを扱うために、多数の関数が用意されていることです。
              従って、生のデータを扱う必要のあるYPStandJSでは、Buffer型を非常に多く用いることになります。
        %section
          %h3 peca.rbの定数と構造体を移植する
          %p
            この節ではYPStandでも最も重要な部分、ypstand/peca.rbのうち、
            定数と構造体を移植します。
          %section
            %h4 定数一覧を移植する
            %p
              Javascriptには定数というものは、(いまのところ)ありません。
              ですから、変数を使うわけですが、Rubyのまま移植しようとすると痛い目をみます。
            %pre
              :preserve
                # ypstand/peca.rbから
                PCP_HELO           = "helo"
                PCP_HELO_AGENT     = "agnt"
                (以下省略)
            %p
              これを素直にJavascriptで書くとこうなります。
            %pre
              :preserve
                var PCP_HELO = "helo";
                var PCP_HELO_AGENT = "agnt";
            %p
              なぜこれがまずいのでしょうか。
              それは別ファイルへエクスポートする時のことを考えるとわかります。
              変数ひとつひとつに対して、<code>exports.PCP_HELO = PCP_HELO;</code>と書かなければならなくなるのです。
              それはあまりにも非効率的です。
            %p
              では何を使うべきか。
              Rubyなどの他言語にある「連想配列」(あるキーに対して値があるようなもの)があればいいのですが、
              Javascriptにはそれそのものはありません。ですが、似たようなものはあります。
              それがオブジェクトです。
            %p
              Javascriptのオブジェクトとは何でしょうか。実は非常に単純な代物です。
              「文字列をキーとした連想配列」。それがオブジェクトです。
              つまり、ある文字列に対して、別の何かが結びつけられるのです。
            %p
              理屈はいいので実際にどうするのかを見てみましょう。
            %pre
              :preserve
                var PCP_CONST = {
                  PCP_HELO           :"helo",
                  PCP_HELO_AGENT     :"agnt",
                  PCP_HELO_OSTYPE    :"ostp",
                  PCP_HELO_SESSIONID :"sid",
                  PCP_HELO_PORT      :"port",
                  (中略)
                  PCP_ERROR_SHUTDOWN         :9,
                  PCP_ERROR_NOROOT           :10,
                  PCP_ERROR_BANNED           :11,
                };
                exports.PCP_CONST = PCP_CONST;
            %p
              Javascriptのオブジェクトは、<code>{ キー文字列 : 値, キー文字列 : 値, ... }</code>という形で作ることが出来ます。
              そして参照、もしくは代入する場合ですが、2つのやり方があります。
            %pre
              :preserve
                var obj["文字列"] = 値;
                var obj.文字列 = 値;
            %p
              この2つはどちらも同じ動作をしますが、前者は変数をキー文字列にしたいときに役に立ちます(後者ではそういう使い方ができません)。
              この文字列の部分を「プロパティ名」と呼び、値のことを「プロパティ」と呼びます。
          %section
            %h4 structを移植する
            %p
              Rubyのstructは構造体とも呼ばれ、
              名前があるメンバ変数を持つクラスです。
              たとえば次のように定義されます。
            %pre
              :preserve
                Meow = Struct.new(:count) do
                  def nya
                  end
                end
            %p
              この節ではstructが使われている重要な構造体、PCPAtomをどうやって移植するのかを考えながら、
              Javascriptでのオブジェクトについて理解していこうと思います。
            %section
              %h5 みんなみんなオブジェクト
              %p
                Javascriptでは(nullとすぐ後に説明するundefinedを除いた)すべてがオブジェクトです。
                そして標準ではstructに類するオブジェクトのコンストラクタは
                %a{:href=>"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects?redirectlocale=ja&redirectslug=JavaScript%2FReference%2FGlobal_Objects"}存在しません
                。
                ですから、必然的に、構造体はオブジェクトで代用することになります。
              %p
                まず、Rubyでの簡単な構造体を見てみましょう。
              %pre
                :preserve
                  Meow = Struct.new(:name)
              %p
                これがRubyでの簡単な構造体の定義の仕方です。
                では、これをJavascriptのオブジェクトを使って書いてみるとどうなるか。
                こうなります。
              %pre
                :preserve
                  function Meow(name) {
                    this.name = name;
                  }
              %p
                結局のところ、一般的なクラスのコンストラクタとして書いているわけです。
                実際に使うときはたとえばこうします。
              %pre
                :preserve
                  var cat = new Meow("chappy");
              %p
                ここで初めてnew演算子が出てきました。これはコンストラクタ関数から新しいオブジェクトを作るための演算子です。
                このようにしてJavascriptでは別の関数からオブジェクトを作成します。
            %section
              %h5 クラス関数を作る
              %p
                Rubyや他の言語ではクラス関数というものを持つことができます。
                つまり、コンストラクタから作られたインスタンスに属さず、
                クラス(Javascriptではコンストラクタ関数)に属する関数です。
                屁理屈はどうでもいいので実際に例を示します。
              %pre
                :preserve
                  function Cat() {
                  }
                  Cat.cry = function() {
                    console.log("Meow.");
                  }
                  Cat.cry();
              %p
                これだけです。
                Javascriptでは関数も例によってオブジェクトなので、
                それに新しくプロパティを作って関数を結びつけてやればいいのです。
            %section
              %h5 thisってなあに？
              %p
                ところで構造体の移植をする際に、
                thisという演算子(そう、thisは演算子です)が出てきました。
                この演算子は何でしょうか。
              %p
                これは一言で言うと、「現在実行されている部分(コンテキスト)のオブジェクトを参照する演算子」です。
                たとえば、これが関数内であれば関数を指しますし、
                グローバルな部分で実行されているのなら、グローバルなオブジェクトを参照します。
              %p
                実際のところ、私がどうこう言うより、
                %a{:href=>"https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/this?redirectlocale=ja&redirectslug=JavaScript%2FReference%2FOperators%2Fthis"}Mozillaのガイド
                を見ていただけるとわかりやすいかと思います。ひどい話ですが。
            %section
              %h5 オブジェクトに属する関数(インスタンス関数)を作る、もしくはprototypeの説明
              %p
                今度は、インスタンス関数から作られた、オブジェクトに属する関数、
                つまり他の言語で言うところのインスタンス関数を作ってみましょう。
              %pre
                :preserve
                  function Cat() {
                  }
                  Cat.prototype.cry = function() {
                    console.log("Meow.");
                  }
              %p
                これでOKですが、ここに突如prototypeプロパティというものが出てきました(演算子ではありません)。
                これはいったい何なのでしょうか。
              %p
                Javascriptでは、オブジェクトが作成されると、prototypeに定義されているプロパティを使って、初期プロパティを生成します。
                これを利用して、他の言語にもある継承を実装することができます。たとえばMDNにあるこの例のように。
              %pre
                :preserve
                  function Employee() {
                    this.name = "";
                    this.dept = "general";
                  }
                  function Manager() {
                    this.reports = [];
                  }
                  Manager.prototype = new Employee();
              %p
                これによって、他の言語で言う、EmployeeクラスからManagerクラスへの継承を実現することができます。
                実際に継承する代わりに、prototypeを代入することによって、初期プロパティを作るのです。
                これが、Javascriptがプロトタイプベースとも言われる由来です。
